// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/voikin/apim-profile-store/internal/usecase.PostgresRepo -o postgres_repo_mock.go -n PostgresRepoMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"github.com/voikin/apim-profile-store/internal/entity"
)

// PostgresRepoMock implements mm_usecase.PostgresRepo
type PostgresRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateApplication          func(ctx context.Context, app *entity.Application) (u1 uuid.UUID, err error)
	funcCreateApplicationOrigin    string
	inspectFuncCreateApplication   func(ctx context.Context, app *entity.Application)
	afterCreateApplicationCounter  uint64
	beforeCreateApplicationCounter uint64
	CreateApplicationMock          mPostgresRepoMockCreateApplication

	funcCreateApplicationProfile          func(ctx context.Context, profile *entity.ApplicationProfile) (u1 uuid.UUID, err error)
	funcCreateApplicationProfileOrigin    string
	inspectFuncCreateApplicationProfile   func(ctx context.Context, profile *entity.ApplicationProfile)
	afterCreateApplicationProfileCounter  uint64
	beforeCreateApplicationProfileCounter uint64
	CreateApplicationProfileMock          mPostgresRepoMockCreateApplicationProfile

	funcDeleteApplication          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteApplicationOrigin    string
	inspectFuncDeleteApplication   func(ctx context.Context, id uuid.UUID)
	afterDeleteApplicationCounter  uint64
	beforeDeleteApplicationCounter uint64
	DeleteApplicationMock          mPostgresRepoMockDeleteApplication

	funcDeleteApplicationProfile          func(ctx context.Context, id uuid.UUID) (err error)
	funcDeleteApplicationProfileOrigin    string
	inspectFuncDeleteApplicationProfile   func(ctx context.Context, id uuid.UUID)
	afterDeleteApplicationProfileCounter  uint64
	beforeDeleteApplicationProfileCounter uint64
	DeleteApplicationProfileMock          mPostgresRepoMockDeleteApplicationProfile

	funcGetApplication          func(ctx context.Context, id uuid.UUID) (ap1 *entity.Application, err error)
	funcGetApplicationOrigin    string
	inspectFuncGetApplication   func(ctx context.Context, id uuid.UUID)
	afterGetApplicationCounter  uint64
	beforeGetApplicationCounter uint64
	GetApplicationMock          mPostgresRepoMockGetApplication

	funcGetApplicationProfileByID          func(ctx context.Context, id uuid.UUID) (ap1 *entity.ApplicationProfile, err error)
	funcGetApplicationProfileByIDOrigin    string
	inspectFuncGetApplicationProfileByID   func(ctx context.Context, id uuid.UUID)
	afterGetApplicationProfileByIDCounter  uint64
	beforeGetApplicationProfileByIDCounter uint64
	GetApplicationProfileByIDMock          mPostgresRepoMockGetApplicationProfileByID

	funcGetApplicationProfileByVersion          func(ctx context.Context, applicationID uuid.UUID, version uint32) (ap1 *entity.ApplicationProfile, err error)
	funcGetApplicationProfileByVersionOrigin    string
	inspectFuncGetApplicationProfileByVersion   func(ctx context.Context, applicationID uuid.UUID, version uint32)
	afterGetApplicationProfileByVersionCounter  uint64
	beforeGetApplicationProfileByVersionCounter uint64
	GetApplicationProfileByVersionMock          mPostgresRepoMockGetApplicationProfileByVersion

	funcGetLatestApplicationProfile          func(ctx context.Context, applicationID uuid.UUID) (ap1 *entity.ApplicationProfile, err error)
	funcGetLatestApplicationProfileOrigin    string
	inspectFuncGetLatestApplicationProfile   func(ctx context.Context, applicationID uuid.UUID)
	afterGetLatestApplicationProfileCounter  uint64
	beforeGetLatestApplicationProfileCounter uint64
	GetLatestApplicationProfileMock          mPostgresRepoMockGetLatestApplicationProfile

	funcGetLatestVersionForUpdate          func(ctx context.Context, applicationID uuid.UUID) (u1 uint32, err error)
	funcGetLatestVersionForUpdateOrigin    string
	inspectFuncGetLatestVersionForUpdate   func(ctx context.Context, applicationID uuid.UUID)
	afterGetLatestVersionForUpdateCounter  uint64
	beforeGetLatestVersionForUpdateCounter uint64
	GetLatestVersionForUpdateMock          mPostgresRepoMockGetLatestVersionForUpdate

	funcListApplicationProfiles          func(ctx context.Context, applicationID uuid.UUID) (apa1 []*entity.ApplicationProfile, err error)
	funcListApplicationProfilesOrigin    string
	inspectFuncListApplicationProfiles   func(ctx context.Context, applicationID uuid.UUID)
	afterListApplicationProfilesCounter  uint64
	beforeListApplicationProfilesCounter uint64
	ListApplicationProfilesMock          mPostgresRepoMockListApplicationProfiles

	funcListApplications          func(ctx context.Context) (apa1 []*entity.Application, err error)
	funcListApplicationsOrigin    string
	inspectFuncListApplications   func(ctx context.Context)
	afterListApplicationsCounter  uint64
	beforeListApplicationsCounter uint64
	ListApplicationsMock          mPostgresRepoMockListApplications

	funcListLatestApplicationProfiles          func(ctx context.Context) (apa1 []*entity.ApplicationProfile, err error)
	funcListLatestApplicationProfilesOrigin    string
	inspectFuncListLatestApplicationProfiles   func(ctx context.Context)
	afterListLatestApplicationProfilesCounter  uint64
	beforeListLatestApplicationProfilesCounter uint64
	ListLatestApplicationProfilesMock          mPostgresRepoMockListLatestApplicationProfiles

	funcUpdateApplication          func(ctx context.Context, app *entity.Application, id uuid.UUID) (err error)
	funcUpdateApplicationOrigin    string
	inspectFuncUpdateApplication   func(ctx context.Context, app *entity.Application, id uuid.UUID)
	afterUpdateApplicationCounter  uint64
	beforeUpdateApplicationCounter uint64
	UpdateApplicationMock          mPostgresRepoMockUpdateApplication

	funcUpdateLatestProfileVersion          func(ctx context.Context, applicationID uuid.UUID, version uint32) (err error)
	funcUpdateLatestProfileVersionOrigin    string
	inspectFuncUpdateLatestProfileVersion   func(ctx context.Context, applicationID uuid.UUID, version uint32)
	afterUpdateLatestProfileVersionCounter  uint64
	beforeUpdateLatestProfileVersionCounter uint64
	UpdateLatestProfileVersionMock          mPostgresRepoMockUpdateLatestProfileVersion
}

// NewPostgresRepoMock returns a mock for mm_usecase.PostgresRepo
func NewPostgresRepoMock(t minimock.Tester) *PostgresRepoMock {
	m := &PostgresRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateApplicationMock = mPostgresRepoMockCreateApplication{mock: m}
	m.CreateApplicationMock.callArgs = []*PostgresRepoMockCreateApplicationParams{}

	m.CreateApplicationProfileMock = mPostgresRepoMockCreateApplicationProfile{mock: m}
	m.CreateApplicationProfileMock.callArgs = []*PostgresRepoMockCreateApplicationProfileParams{}

	m.DeleteApplicationMock = mPostgresRepoMockDeleteApplication{mock: m}
	m.DeleteApplicationMock.callArgs = []*PostgresRepoMockDeleteApplicationParams{}

	m.DeleteApplicationProfileMock = mPostgresRepoMockDeleteApplicationProfile{mock: m}
	m.DeleteApplicationProfileMock.callArgs = []*PostgresRepoMockDeleteApplicationProfileParams{}

	m.GetApplicationMock = mPostgresRepoMockGetApplication{mock: m}
	m.GetApplicationMock.callArgs = []*PostgresRepoMockGetApplicationParams{}

	m.GetApplicationProfileByIDMock = mPostgresRepoMockGetApplicationProfileByID{mock: m}
	m.GetApplicationProfileByIDMock.callArgs = []*PostgresRepoMockGetApplicationProfileByIDParams{}

	m.GetApplicationProfileByVersionMock = mPostgresRepoMockGetApplicationProfileByVersion{mock: m}
	m.GetApplicationProfileByVersionMock.callArgs = []*PostgresRepoMockGetApplicationProfileByVersionParams{}

	m.GetLatestApplicationProfileMock = mPostgresRepoMockGetLatestApplicationProfile{mock: m}
	m.GetLatestApplicationProfileMock.callArgs = []*PostgresRepoMockGetLatestApplicationProfileParams{}

	m.GetLatestVersionForUpdateMock = mPostgresRepoMockGetLatestVersionForUpdate{mock: m}
	m.GetLatestVersionForUpdateMock.callArgs = []*PostgresRepoMockGetLatestVersionForUpdateParams{}

	m.ListApplicationProfilesMock = mPostgresRepoMockListApplicationProfiles{mock: m}
	m.ListApplicationProfilesMock.callArgs = []*PostgresRepoMockListApplicationProfilesParams{}

	m.ListApplicationsMock = mPostgresRepoMockListApplications{mock: m}
	m.ListApplicationsMock.callArgs = []*PostgresRepoMockListApplicationsParams{}

	m.ListLatestApplicationProfilesMock = mPostgresRepoMockListLatestApplicationProfiles{mock: m}
	m.ListLatestApplicationProfilesMock.callArgs = []*PostgresRepoMockListLatestApplicationProfilesParams{}

	m.UpdateApplicationMock = mPostgresRepoMockUpdateApplication{mock: m}
	m.UpdateApplicationMock.callArgs = []*PostgresRepoMockUpdateApplicationParams{}

	m.UpdateLatestProfileVersionMock = mPostgresRepoMockUpdateLatestProfileVersion{mock: m}
	m.UpdateLatestProfileVersionMock.callArgs = []*PostgresRepoMockUpdateLatestProfileVersionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPostgresRepoMockCreateApplication struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockCreateApplicationExpectation
	expectations       []*PostgresRepoMockCreateApplicationExpectation

	callArgs []*PostgresRepoMockCreateApplicationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockCreateApplicationExpectation specifies expectation struct of the PostgresRepo.CreateApplication
type PostgresRepoMockCreateApplicationExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockCreateApplicationParams
	paramPtrs          *PostgresRepoMockCreateApplicationParamPtrs
	expectationOrigins PostgresRepoMockCreateApplicationExpectationOrigins
	results            *PostgresRepoMockCreateApplicationResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockCreateApplicationParams contains parameters of the PostgresRepo.CreateApplication
type PostgresRepoMockCreateApplicationParams struct {
	ctx context.Context
	app *entity.Application
}

// PostgresRepoMockCreateApplicationParamPtrs contains pointers to parameters of the PostgresRepo.CreateApplication
type PostgresRepoMockCreateApplicationParamPtrs struct {
	ctx *context.Context
	app **entity.Application
}

// PostgresRepoMockCreateApplicationResults contains results of the PostgresRepo.CreateApplication
type PostgresRepoMockCreateApplicationResults struct {
	u1  uuid.UUID
	err error
}

// PostgresRepoMockCreateApplicationOrigins contains origins of expectations of the PostgresRepo.CreateApplication
type PostgresRepoMockCreateApplicationExpectationOrigins struct {
	origin    string
	originCtx string
	originApp string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateApplication *mPostgresRepoMockCreateApplication) Optional() *mPostgresRepoMockCreateApplication {
	mmCreateApplication.optional = true
	return mmCreateApplication
}

// Expect sets up expected params for PostgresRepo.CreateApplication
func (mmCreateApplication *mPostgresRepoMockCreateApplication) Expect(ctx context.Context, app *entity.Application) *mPostgresRepoMockCreateApplication {
	if mmCreateApplication.mock.funcCreateApplication != nil {
		mmCreateApplication.mock.t.Fatalf("PostgresRepoMock.CreateApplication mock is already set by Set")
	}

	if mmCreateApplication.defaultExpectation == nil {
		mmCreateApplication.defaultExpectation = &PostgresRepoMockCreateApplicationExpectation{}
	}

	if mmCreateApplication.defaultExpectation.paramPtrs != nil {
		mmCreateApplication.mock.t.Fatalf("PostgresRepoMock.CreateApplication mock is already set by ExpectParams functions")
	}

	mmCreateApplication.defaultExpectation.params = &PostgresRepoMockCreateApplicationParams{ctx, app}
	mmCreateApplication.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateApplication.expectations {
		if minimock.Equal(e.params, mmCreateApplication.defaultExpectation.params) {
			mmCreateApplication.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateApplication.defaultExpectation.params)
		}
	}

	return mmCreateApplication
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.CreateApplication
func (mmCreateApplication *mPostgresRepoMockCreateApplication) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockCreateApplication {
	if mmCreateApplication.mock.funcCreateApplication != nil {
		mmCreateApplication.mock.t.Fatalf("PostgresRepoMock.CreateApplication mock is already set by Set")
	}

	if mmCreateApplication.defaultExpectation == nil {
		mmCreateApplication.defaultExpectation = &PostgresRepoMockCreateApplicationExpectation{}
	}

	if mmCreateApplication.defaultExpectation.params != nil {
		mmCreateApplication.mock.t.Fatalf("PostgresRepoMock.CreateApplication mock is already set by Expect")
	}

	if mmCreateApplication.defaultExpectation.paramPtrs == nil {
		mmCreateApplication.defaultExpectation.paramPtrs = &PostgresRepoMockCreateApplicationParamPtrs{}
	}
	mmCreateApplication.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateApplication.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateApplication
}

// ExpectAppParam2 sets up expected param app for PostgresRepo.CreateApplication
func (mmCreateApplication *mPostgresRepoMockCreateApplication) ExpectAppParam2(app *entity.Application) *mPostgresRepoMockCreateApplication {
	if mmCreateApplication.mock.funcCreateApplication != nil {
		mmCreateApplication.mock.t.Fatalf("PostgresRepoMock.CreateApplication mock is already set by Set")
	}

	if mmCreateApplication.defaultExpectation == nil {
		mmCreateApplication.defaultExpectation = &PostgresRepoMockCreateApplicationExpectation{}
	}

	if mmCreateApplication.defaultExpectation.params != nil {
		mmCreateApplication.mock.t.Fatalf("PostgresRepoMock.CreateApplication mock is already set by Expect")
	}

	if mmCreateApplication.defaultExpectation.paramPtrs == nil {
		mmCreateApplication.defaultExpectation.paramPtrs = &PostgresRepoMockCreateApplicationParamPtrs{}
	}
	mmCreateApplication.defaultExpectation.paramPtrs.app = &app
	mmCreateApplication.defaultExpectation.expectationOrigins.originApp = minimock.CallerInfo(1)

	return mmCreateApplication
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.CreateApplication
func (mmCreateApplication *mPostgresRepoMockCreateApplication) Inspect(f func(ctx context.Context, app *entity.Application)) *mPostgresRepoMockCreateApplication {
	if mmCreateApplication.mock.inspectFuncCreateApplication != nil {
		mmCreateApplication.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.CreateApplication")
	}

	mmCreateApplication.mock.inspectFuncCreateApplication = f

	return mmCreateApplication
}

// Return sets up results that will be returned by PostgresRepo.CreateApplication
func (mmCreateApplication *mPostgresRepoMockCreateApplication) Return(u1 uuid.UUID, err error) *PostgresRepoMock {
	if mmCreateApplication.mock.funcCreateApplication != nil {
		mmCreateApplication.mock.t.Fatalf("PostgresRepoMock.CreateApplication mock is already set by Set")
	}

	if mmCreateApplication.defaultExpectation == nil {
		mmCreateApplication.defaultExpectation = &PostgresRepoMockCreateApplicationExpectation{mock: mmCreateApplication.mock}
	}
	mmCreateApplication.defaultExpectation.results = &PostgresRepoMockCreateApplicationResults{u1, err}
	mmCreateApplication.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateApplication.mock
}

// Set uses given function f to mock the PostgresRepo.CreateApplication method
func (mmCreateApplication *mPostgresRepoMockCreateApplication) Set(f func(ctx context.Context, app *entity.Application) (u1 uuid.UUID, err error)) *PostgresRepoMock {
	if mmCreateApplication.defaultExpectation != nil {
		mmCreateApplication.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.CreateApplication method")
	}

	if len(mmCreateApplication.expectations) > 0 {
		mmCreateApplication.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.CreateApplication method")
	}

	mmCreateApplication.mock.funcCreateApplication = f
	mmCreateApplication.mock.funcCreateApplicationOrigin = minimock.CallerInfo(1)
	return mmCreateApplication.mock
}

// When sets expectation for the PostgresRepo.CreateApplication which will trigger the result defined by the following
// Then helper
func (mmCreateApplication *mPostgresRepoMockCreateApplication) When(ctx context.Context, app *entity.Application) *PostgresRepoMockCreateApplicationExpectation {
	if mmCreateApplication.mock.funcCreateApplication != nil {
		mmCreateApplication.mock.t.Fatalf("PostgresRepoMock.CreateApplication mock is already set by Set")
	}

	expectation := &PostgresRepoMockCreateApplicationExpectation{
		mock:               mmCreateApplication.mock,
		params:             &PostgresRepoMockCreateApplicationParams{ctx, app},
		expectationOrigins: PostgresRepoMockCreateApplicationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateApplication.expectations = append(mmCreateApplication.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.CreateApplication return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockCreateApplicationExpectation) Then(u1 uuid.UUID, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockCreateApplicationResults{u1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.CreateApplication should be invoked
func (mmCreateApplication *mPostgresRepoMockCreateApplication) Times(n uint64) *mPostgresRepoMockCreateApplication {
	if n == 0 {
		mmCreateApplication.mock.t.Fatalf("Times of PostgresRepoMock.CreateApplication mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateApplication.expectedInvocations, n)
	mmCreateApplication.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateApplication
}

func (mmCreateApplication *mPostgresRepoMockCreateApplication) invocationsDone() bool {
	if len(mmCreateApplication.expectations) == 0 && mmCreateApplication.defaultExpectation == nil && mmCreateApplication.mock.funcCreateApplication == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateApplication.mock.afterCreateApplicationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateApplication.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateApplication implements mm_usecase.PostgresRepo
func (mmCreateApplication *PostgresRepoMock) CreateApplication(ctx context.Context, app *entity.Application) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreateApplication.beforeCreateApplicationCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateApplication.afterCreateApplicationCounter, 1)

	mmCreateApplication.t.Helper()

	if mmCreateApplication.inspectFuncCreateApplication != nil {
		mmCreateApplication.inspectFuncCreateApplication(ctx, app)
	}

	mm_params := PostgresRepoMockCreateApplicationParams{ctx, app}

	// Record call args
	mmCreateApplication.CreateApplicationMock.mutex.Lock()
	mmCreateApplication.CreateApplicationMock.callArgs = append(mmCreateApplication.CreateApplicationMock.callArgs, &mm_params)
	mmCreateApplication.CreateApplicationMock.mutex.Unlock()

	for _, e := range mmCreateApplication.CreateApplicationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateApplication.CreateApplicationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateApplication.CreateApplicationMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateApplication.CreateApplicationMock.defaultExpectation.params
		mm_want_ptrs := mmCreateApplication.CreateApplicationMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockCreateApplicationParams{ctx, app}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateApplication.t.Errorf("PostgresRepoMock.CreateApplication got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateApplication.CreateApplicationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.app != nil && !minimock.Equal(*mm_want_ptrs.app, mm_got.app) {
				mmCreateApplication.t.Errorf("PostgresRepoMock.CreateApplication got unexpected parameter app, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateApplication.CreateApplicationMock.defaultExpectation.expectationOrigins.originApp, *mm_want_ptrs.app, mm_got.app, minimock.Diff(*mm_want_ptrs.app, mm_got.app))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateApplication.t.Errorf("PostgresRepoMock.CreateApplication got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateApplication.CreateApplicationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateApplication.CreateApplicationMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateApplication.t.Fatal("No results are set for the PostgresRepoMock.CreateApplication")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateApplication.funcCreateApplication != nil {
		return mmCreateApplication.funcCreateApplication(ctx, app)
	}
	mmCreateApplication.t.Fatalf("Unexpected call to PostgresRepoMock.CreateApplication. %v %v", ctx, app)
	return
}

// CreateApplicationAfterCounter returns a count of finished PostgresRepoMock.CreateApplication invocations
func (mmCreateApplication *PostgresRepoMock) CreateApplicationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApplication.afterCreateApplicationCounter)
}

// CreateApplicationBeforeCounter returns a count of PostgresRepoMock.CreateApplication invocations
func (mmCreateApplication *PostgresRepoMock) CreateApplicationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApplication.beforeCreateApplicationCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.CreateApplication.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateApplication *mPostgresRepoMockCreateApplication) Calls() []*PostgresRepoMockCreateApplicationParams {
	mmCreateApplication.mutex.RLock()

	argCopy := make([]*PostgresRepoMockCreateApplicationParams, len(mmCreateApplication.callArgs))
	copy(argCopy, mmCreateApplication.callArgs)

	mmCreateApplication.mutex.RUnlock()

	return argCopy
}

// MinimockCreateApplicationDone returns true if the count of the CreateApplication invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockCreateApplicationDone() bool {
	if m.CreateApplicationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateApplicationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateApplicationMock.invocationsDone()
}

// MinimockCreateApplicationInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockCreateApplicationInspect() {
	for _, e := range m.CreateApplicationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.CreateApplication at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateApplicationCounter := mm_atomic.LoadUint64(&m.afterCreateApplicationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateApplicationMock.defaultExpectation != nil && afterCreateApplicationCounter < 1 {
		if m.CreateApplicationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.CreateApplication at\n%s", m.CreateApplicationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.CreateApplication at\n%s with params: %#v", m.CreateApplicationMock.defaultExpectation.expectationOrigins.origin, *m.CreateApplicationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateApplication != nil && afterCreateApplicationCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.CreateApplication at\n%s", m.funcCreateApplicationOrigin)
	}

	if !m.CreateApplicationMock.invocationsDone() && afterCreateApplicationCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.CreateApplication at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateApplicationMock.expectedInvocations), m.CreateApplicationMock.expectedInvocationsOrigin, afterCreateApplicationCounter)
	}
}

type mPostgresRepoMockCreateApplicationProfile struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockCreateApplicationProfileExpectation
	expectations       []*PostgresRepoMockCreateApplicationProfileExpectation

	callArgs []*PostgresRepoMockCreateApplicationProfileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockCreateApplicationProfileExpectation specifies expectation struct of the PostgresRepo.CreateApplicationProfile
type PostgresRepoMockCreateApplicationProfileExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockCreateApplicationProfileParams
	paramPtrs          *PostgresRepoMockCreateApplicationProfileParamPtrs
	expectationOrigins PostgresRepoMockCreateApplicationProfileExpectationOrigins
	results            *PostgresRepoMockCreateApplicationProfileResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockCreateApplicationProfileParams contains parameters of the PostgresRepo.CreateApplicationProfile
type PostgresRepoMockCreateApplicationProfileParams struct {
	ctx     context.Context
	profile *entity.ApplicationProfile
}

// PostgresRepoMockCreateApplicationProfileParamPtrs contains pointers to parameters of the PostgresRepo.CreateApplicationProfile
type PostgresRepoMockCreateApplicationProfileParamPtrs struct {
	ctx     *context.Context
	profile **entity.ApplicationProfile
}

// PostgresRepoMockCreateApplicationProfileResults contains results of the PostgresRepo.CreateApplicationProfile
type PostgresRepoMockCreateApplicationProfileResults struct {
	u1  uuid.UUID
	err error
}

// PostgresRepoMockCreateApplicationProfileOrigins contains origins of expectations of the PostgresRepo.CreateApplicationProfile
type PostgresRepoMockCreateApplicationProfileExpectationOrigins struct {
	origin        string
	originCtx     string
	originProfile string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) Optional() *mPostgresRepoMockCreateApplicationProfile {
	mmCreateApplicationProfile.optional = true
	return mmCreateApplicationProfile
}

// Expect sets up expected params for PostgresRepo.CreateApplicationProfile
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) Expect(ctx context.Context, profile *entity.ApplicationProfile) *mPostgresRepoMockCreateApplicationProfile {
	if mmCreateApplicationProfile.mock.funcCreateApplicationProfile != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("PostgresRepoMock.CreateApplicationProfile mock is already set by Set")
	}

	if mmCreateApplicationProfile.defaultExpectation == nil {
		mmCreateApplicationProfile.defaultExpectation = &PostgresRepoMockCreateApplicationProfileExpectation{}
	}

	if mmCreateApplicationProfile.defaultExpectation.paramPtrs != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("PostgresRepoMock.CreateApplicationProfile mock is already set by ExpectParams functions")
	}

	mmCreateApplicationProfile.defaultExpectation.params = &PostgresRepoMockCreateApplicationProfileParams{ctx, profile}
	mmCreateApplicationProfile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateApplicationProfile.expectations {
		if minimock.Equal(e.params, mmCreateApplicationProfile.defaultExpectation.params) {
			mmCreateApplicationProfile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateApplicationProfile.defaultExpectation.params)
		}
	}

	return mmCreateApplicationProfile
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.CreateApplicationProfile
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockCreateApplicationProfile {
	if mmCreateApplicationProfile.mock.funcCreateApplicationProfile != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("PostgresRepoMock.CreateApplicationProfile mock is already set by Set")
	}

	if mmCreateApplicationProfile.defaultExpectation == nil {
		mmCreateApplicationProfile.defaultExpectation = &PostgresRepoMockCreateApplicationProfileExpectation{}
	}

	if mmCreateApplicationProfile.defaultExpectation.params != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("PostgresRepoMock.CreateApplicationProfile mock is already set by Expect")
	}

	if mmCreateApplicationProfile.defaultExpectation.paramPtrs == nil {
		mmCreateApplicationProfile.defaultExpectation.paramPtrs = &PostgresRepoMockCreateApplicationProfileParamPtrs{}
	}
	mmCreateApplicationProfile.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateApplicationProfile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateApplicationProfile
}

// ExpectProfileParam2 sets up expected param profile for PostgresRepo.CreateApplicationProfile
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) ExpectProfileParam2(profile *entity.ApplicationProfile) *mPostgresRepoMockCreateApplicationProfile {
	if mmCreateApplicationProfile.mock.funcCreateApplicationProfile != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("PostgresRepoMock.CreateApplicationProfile mock is already set by Set")
	}

	if mmCreateApplicationProfile.defaultExpectation == nil {
		mmCreateApplicationProfile.defaultExpectation = &PostgresRepoMockCreateApplicationProfileExpectation{}
	}

	if mmCreateApplicationProfile.defaultExpectation.params != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("PostgresRepoMock.CreateApplicationProfile mock is already set by Expect")
	}

	if mmCreateApplicationProfile.defaultExpectation.paramPtrs == nil {
		mmCreateApplicationProfile.defaultExpectation.paramPtrs = &PostgresRepoMockCreateApplicationProfileParamPtrs{}
	}
	mmCreateApplicationProfile.defaultExpectation.paramPtrs.profile = &profile
	mmCreateApplicationProfile.defaultExpectation.expectationOrigins.originProfile = minimock.CallerInfo(1)

	return mmCreateApplicationProfile
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.CreateApplicationProfile
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) Inspect(f func(ctx context.Context, profile *entity.ApplicationProfile)) *mPostgresRepoMockCreateApplicationProfile {
	if mmCreateApplicationProfile.mock.inspectFuncCreateApplicationProfile != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.CreateApplicationProfile")
	}

	mmCreateApplicationProfile.mock.inspectFuncCreateApplicationProfile = f

	return mmCreateApplicationProfile
}

// Return sets up results that will be returned by PostgresRepo.CreateApplicationProfile
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) Return(u1 uuid.UUID, err error) *PostgresRepoMock {
	if mmCreateApplicationProfile.mock.funcCreateApplicationProfile != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("PostgresRepoMock.CreateApplicationProfile mock is already set by Set")
	}

	if mmCreateApplicationProfile.defaultExpectation == nil {
		mmCreateApplicationProfile.defaultExpectation = &PostgresRepoMockCreateApplicationProfileExpectation{mock: mmCreateApplicationProfile.mock}
	}
	mmCreateApplicationProfile.defaultExpectation.results = &PostgresRepoMockCreateApplicationProfileResults{u1, err}
	mmCreateApplicationProfile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateApplicationProfile.mock
}

// Set uses given function f to mock the PostgresRepo.CreateApplicationProfile method
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) Set(f func(ctx context.Context, profile *entity.ApplicationProfile) (u1 uuid.UUID, err error)) *PostgresRepoMock {
	if mmCreateApplicationProfile.defaultExpectation != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.CreateApplicationProfile method")
	}

	if len(mmCreateApplicationProfile.expectations) > 0 {
		mmCreateApplicationProfile.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.CreateApplicationProfile method")
	}

	mmCreateApplicationProfile.mock.funcCreateApplicationProfile = f
	mmCreateApplicationProfile.mock.funcCreateApplicationProfileOrigin = minimock.CallerInfo(1)
	return mmCreateApplicationProfile.mock
}

// When sets expectation for the PostgresRepo.CreateApplicationProfile which will trigger the result defined by the following
// Then helper
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) When(ctx context.Context, profile *entity.ApplicationProfile) *PostgresRepoMockCreateApplicationProfileExpectation {
	if mmCreateApplicationProfile.mock.funcCreateApplicationProfile != nil {
		mmCreateApplicationProfile.mock.t.Fatalf("PostgresRepoMock.CreateApplicationProfile mock is already set by Set")
	}

	expectation := &PostgresRepoMockCreateApplicationProfileExpectation{
		mock:               mmCreateApplicationProfile.mock,
		params:             &PostgresRepoMockCreateApplicationProfileParams{ctx, profile},
		expectationOrigins: PostgresRepoMockCreateApplicationProfileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateApplicationProfile.expectations = append(mmCreateApplicationProfile.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.CreateApplicationProfile return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockCreateApplicationProfileExpectation) Then(u1 uuid.UUID, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockCreateApplicationProfileResults{u1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.CreateApplicationProfile should be invoked
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) Times(n uint64) *mPostgresRepoMockCreateApplicationProfile {
	if n == 0 {
		mmCreateApplicationProfile.mock.t.Fatalf("Times of PostgresRepoMock.CreateApplicationProfile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateApplicationProfile.expectedInvocations, n)
	mmCreateApplicationProfile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateApplicationProfile
}

func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) invocationsDone() bool {
	if len(mmCreateApplicationProfile.expectations) == 0 && mmCreateApplicationProfile.defaultExpectation == nil && mmCreateApplicationProfile.mock.funcCreateApplicationProfile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateApplicationProfile.mock.afterCreateApplicationProfileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateApplicationProfile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateApplicationProfile implements mm_usecase.PostgresRepo
func (mmCreateApplicationProfile *PostgresRepoMock) CreateApplicationProfile(ctx context.Context, profile *entity.ApplicationProfile) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreateApplicationProfile.beforeCreateApplicationProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateApplicationProfile.afterCreateApplicationProfileCounter, 1)

	mmCreateApplicationProfile.t.Helper()

	if mmCreateApplicationProfile.inspectFuncCreateApplicationProfile != nil {
		mmCreateApplicationProfile.inspectFuncCreateApplicationProfile(ctx, profile)
	}

	mm_params := PostgresRepoMockCreateApplicationProfileParams{ctx, profile}

	// Record call args
	mmCreateApplicationProfile.CreateApplicationProfileMock.mutex.Lock()
	mmCreateApplicationProfile.CreateApplicationProfileMock.callArgs = append(mmCreateApplicationProfile.CreateApplicationProfileMock.callArgs, &mm_params)
	mmCreateApplicationProfile.CreateApplicationProfileMock.mutex.Unlock()

	for _, e := range mmCreateApplicationProfile.CreateApplicationProfileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateApplicationProfile.CreateApplicationProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateApplicationProfile.CreateApplicationProfileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateApplicationProfile.CreateApplicationProfileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateApplicationProfile.CreateApplicationProfileMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockCreateApplicationProfileParams{ctx, profile}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateApplicationProfile.t.Errorf("PostgresRepoMock.CreateApplicationProfile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateApplicationProfile.CreateApplicationProfileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.profile != nil && !minimock.Equal(*mm_want_ptrs.profile, mm_got.profile) {
				mmCreateApplicationProfile.t.Errorf("PostgresRepoMock.CreateApplicationProfile got unexpected parameter profile, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateApplicationProfile.CreateApplicationProfileMock.defaultExpectation.expectationOrigins.originProfile, *mm_want_ptrs.profile, mm_got.profile, minimock.Diff(*mm_want_ptrs.profile, mm_got.profile))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateApplicationProfile.t.Errorf("PostgresRepoMock.CreateApplicationProfile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateApplicationProfile.CreateApplicationProfileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateApplicationProfile.CreateApplicationProfileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateApplicationProfile.t.Fatal("No results are set for the PostgresRepoMock.CreateApplicationProfile")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateApplicationProfile.funcCreateApplicationProfile != nil {
		return mmCreateApplicationProfile.funcCreateApplicationProfile(ctx, profile)
	}
	mmCreateApplicationProfile.t.Fatalf("Unexpected call to PostgresRepoMock.CreateApplicationProfile. %v %v", ctx, profile)
	return
}

// CreateApplicationProfileAfterCounter returns a count of finished PostgresRepoMock.CreateApplicationProfile invocations
func (mmCreateApplicationProfile *PostgresRepoMock) CreateApplicationProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApplicationProfile.afterCreateApplicationProfileCounter)
}

// CreateApplicationProfileBeforeCounter returns a count of PostgresRepoMock.CreateApplicationProfile invocations
func (mmCreateApplicationProfile *PostgresRepoMock) CreateApplicationProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApplicationProfile.beforeCreateApplicationProfileCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.CreateApplicationProfile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateApplicationProfile *mPostgresRepoMockCreateApplicationProfile) Calls() []*PostgresRepoMockCreateApplicationProfileParams {
	mmCreateApplicationProfile.mutex.RLock()

	argCopy := make([]*PostgresRepoMockCreateApplicationProfileParams, len(mmCreateApplicationProfile.callArgs))
	copy(argCopy, mmCreateApplicationProfile.callArgs)

	mmCreateApplicationProfile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateApplicationProfileDone returns true if the count of the CreateApplicationProfile invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockCreateApplicationProfileDone() bool {
	if m.CreateApplicationProfileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateApplicationProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateApplicationProfileMock.invocationsDone()
}

// MinimockCreateApplicationProfileInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockCreateApplicationProfileInspect() {
	for _, e := range m.CreateApplicationProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.CreateApplicationProfile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateApplicationProfileCounter := mm_atomic.LoadUint64(&m.afterCreateApplicationProfileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateApplicationProfileMock.defaultExpectation != nil && afterCreateApplicationProfileCounter < 1 {
		if m.CreateApplicationProfileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.CreateApplicationProfile at\n%s", m.CreateApplicationProfileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.CreateApplicationProfile at\n%s with params: %#v", m.CreateApplicationProfileMock.defaultExpectation.expectationOrigins.origin, *m.CreateApplicationProfileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateApplicationProfile != nil && afterCreateApplicationProfileCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.CreateApplicationProfile at\n%s", m.funcCreateApplicationProfileOrigin)
	}

	if !m.CreateApplicationProfileMock.invocationsDone() && afterCreateApplicationProfileCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.CreateApplicationProfile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateApplicationProfileMock.expectedInvocations), m.CreateApplicationProfileMock.expectedInvocationsOrigin, afterCreateApplicationProfileCounter)
	}
}

type mPostgresRepoMockDeleteApplication struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockDeleteApplicationExpectation
	expectations       []*PostgresRepoMockDeleteApplicationExpectation

	callArgs []*PostgresRepoMockDeleteApplicationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockDeleteApplicationExpectation specifies expectation struct of the PostgresRepo.DeleteApplication
type PostgresRepoMockDeleteApplicationExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockDeleteApplicationParams
	paramPtrs          *PostgresRepoMockDeleteApplicationParamPtrs
	expectationOrigins PostgresRepoMockDeleteApplicationExpectationOrigins
	results            *PostgresRepoMockDeleteApplicationResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockDeleteApplicationParams contains parameters of the PostgresRepo.DeleteApplication
type PostgresRepoMockDeleteApplicationParams struct {
	ctx context.Context
	id  uuid.UUID
}

// PostgresRepoMockDeleteApplicationParamPtrs contains pointers to parameters of the PostgresRepo.DeleteApplication
type PostgresRepoMockDeleteApplicationParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// PostgresRepoMockDeleteApplicationResults contains results of the PostgresRepo.DeleteApplication
type PostgresRepoMockDeleteApplicationResults struct {
	err error
}

// PostgresRepoMockDeleteApplicationOrigins contains origins of expectations of the PostgresRepo.DeleteApplication
type PostgresRepoMockDeleteApplicationExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) Optional() *mPostgresRepoMockDeleteApplication {
	mmDeleteApplication.optional = true
	return mmDeleteApplication
}

// Expect sets up expected params for PostgresRepo.DeleteApplication
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) Expect(ctx context.Context, id uuid.UUID) *mPostgresRepoMockDeleteApplication {
	if mmDeleteApplication.mock.funcDeleteApplication != nil {
		mmDeleteApplication.mock.t.Fatalf("PostgresRepoMock.DeleteApplication mock is already set by Set")
	}

	if mmDeleteApplication.defaultExpectation == nil {
		mmDeleteApplication.defaultExpectation = &PostgresRepoMockDeleteApplicationExpectation{}
	}

	if mmDeleteApplication.defaultExpectation.paramPtrs != nil {
		mmDeleteApplication.mock.t.Fatalf("PostgresRepoMock.DeleteApplication mock is already set by ExpectParams functions")
	}

	mmDeleteApplication.defaultExpectation.params = &PostgresRepoMockDeleteApplicationParams{ctx, id}
	mmDeleteApplication.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteApplication.expectations {
		if minimock.Equal(e.params, mmDeleteApplication.defaultExpectation.params) {
			mmDeleteApplication.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteApplication.defaultExpectation.params)
		}
	}

	return mmDeleteApplication
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.DeleteApplication
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockDeleteApplication {
	if mmDeleteApplication.mock.funcDeleteApplication != nil {
		mmDeleteApplication.mock.t.Fatalf("PostgresRepoMock.DeleteApplication mock is already set by Set")
	}

	if mmDeleteApplication.defaultExpectation == nil {
		mmDeleteApplication.defaultExpectation = &PostgresRepoMockDeleteApplicationExpectation{}
	}

	if mmDeleteApplication.defaultExpectation.params != nil {
		mmDeleteApplication.mock.t.Fatalf("PostgresRepoMock.DeleteApplication mock is already set by Expect")
	}

	if mmDeleteApplication.defaultExpectation.paramPtrs == nil {
		mmDeleteApplication.defaultExpectation.paramPtrs = &PostgresRepoMockDeleteApplicationParamPtrs{}
	}
	mmDeleteApplication.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteApplication.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteApplication
}

// ExpectIdParam2 sets up expected param id for PostgresRepo.DeleteApplication
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) ExpectIdParam2(id uuid.UUID) *mPostgresRepoMockDeleteApplication {
	if mmDeleteApplication.mock.funcDeleteApplication != nil {
		mmDeleteApplication.mock.t.Fatalf("PostgresRepoMock.DeleteApplication mock is already set by Set")
	}

	if mmDeleteApplication.defaultExpectation == nil {
		mmDeleteApplication.defaultExpectation = &PostgresRepoMockDeleteApplicationExpectation{}
	}

	if mmDeleteApplication.defaultExpectation.params != nil {
		mmDeleteApplication.mock.t.Fatalf("PostgresRepoMock.DeleteApplication mock is already set by Expect")
	}

	if mmDeleteApplication.defaultExpectation.paramPtrs == nil {
		mmDeleteApplication.defaultExpectation.paramPtrs = &PostgresRepoMockDeleteApplicationParamPtrs{}
	}
	mmDeleteApplication.defaultExpectation.paramPtrs.id = &id
	mmDeleteApplication.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteApplication
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.DeleteApplication
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) Inspect(f func(ctx context.Context, id uuid.UUID)) *mPostgresRepoMockDeleteApplication {
	if mmDeleteApplication.mock.inspectFuncDeleteApplication != nil {
		mmDeleteApplication.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.DeleteApplication")
	}

	mmDeleteApplication.mock.inspectFuncDeleteApplication = f

	return mmDeleteApplication
}

// Return sets up results that will be returned by PostgresRepo.DeleteApplication
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) Return(err error) *PostgresRepoMock {
	if mmDeleteApplication.mock.funcDeleteApplication != nil {
		mmDeleteApplication.mock.t.Fatalf("PostgresRepoMock.DeleteApplication mock is already set by Set")
	}

	if mmDeleteApplication.defaultExpectation == nil {
		mmDeleteApplication.defaultExpectation = &PostgresRepoMockDeleteApplicationExpectation{mock: mmDeleteApplication.mock}
	}
	mmDeleteApplication.defaultExpectation.results = &PostgresRepoMockDeleteApplicationResults{err}
	mmDeleteApplication.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteApplication.mock
}

// Set uses given function f to mock the PostgresRepo.DeleteApplication method
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *PostgresRepoMock {
	if mmDeleteApplication.defaultExpectation != nil {
		mmDeleteApplication.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.DeleteApplication method")
	}

	if len(mmDeleteApplication.expectations) > 0 {
		mmDeleteApplication.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.DeleteApplication method")
	}

	mmDeleteApplication.mock.funcDeleteApplication = f
	mmDeleteApplication.mock.funcDeleteApplicationOrigin = minimock.CallerInfo(1)
	return mmDeleteApplication.mock
}

// When sets expectation for the PostgresRepo.DeleteApplication which will trigger the result defined by the following
// Then helper
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) When(ctx context.Context, id uuid.UUID) *PostgresRepoMockDeleteApplicationExpectation {
	if mmDeleteApplication.mock.funcDeleteApplication != nil {
		mmDeleteApplication.mock.t.Fatalf("PostgresRepoMock.DeleteApplication mock is already set by Set")
	}

	expectation := &PostgresRepoMockDeleteApplicationExpectation{
		mock:               mmDeleteApplication.mock,
		params:             &PostgresRepoMockDeleteApplicationParams{ctx, id},
		expectationOrigins: PostgresRepoMockDeleteApplicationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteApplication.expectations = append(mmDeleteApplication.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.DeleteApplication return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockDeleteApplicationExpectation) Then(err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockDeleteApplicationResults{err}
	return e.mock
}

// Times sets number of times PostgresRepo.DeleteApplication should be invoked
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) Times(n uint64) *mPostgresRepoMockDeleteApplication {
	if n == 0 {
		mmDeleteApplication.mock.t.Fatalf("Times of PostgresRepoMock.DeleteApplication mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteApplication.expectedInvocations, n)
	mmDeleteApplication.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteApplication
}

func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) invocationsDone() bool {
	if len(mmDeleteApplication.expectations) == 0 && mmDeleteApplication.defaultExpectation == nil && mmDeleteApplication.mock.funcDeleteApplication == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteApplication.mock.afterDeleteApplicationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteApplication.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteApplication implements mm_usecase.PostgresRepo
func (mmDeleteApplication *PostgresRepoMock) DeleteApplication(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteApplication.beforeDeleteApplicationCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteApplication.afterDeleteApplicationCounter, 1)

	mmDeleteApplication.t.Helper()

	if mmDeleteApplication.inspectFuncDeleteApplication != nil {
		mmDeleteApplication.inspectFuncDeleteApplication(ctx, id)
	}

	mm_params := PostgresRepoMockDeleteApplicationParams{ctx, id}

	// Record call args
	mmDeleteApplication.DeleteApplicationMock.mutex.Lock()
	mmDeleteApplication.DeleteApplicationMock.callArgs = append(mmDeleteApplication.DeleteApplicationMock.callArgs, &mm_params)
	mmDeleteApplication.DeleteApplicationMock.mutex.Unlock()

	for _, e := range mmDeleteApplication.DeleteApplicationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteApplication.DeleteApplicationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteApplication.DeleteApplicationMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteApplication.DeleteApplicationMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteApplication.DeleteApplicationMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockDeleteApplicationParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteApplication.t.Errorf("PostgresRepoMock.DeleteApplication got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteApplication.DeleteApplicationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteApplication.t.Errorf("PostgresRepoMock.DeleteApplication got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteApplication.DeleteApplicationMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteApplication.t.Errorf("PostgresRepoMock.DeleteApplication got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteApplication.DeleteApplicationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteApplication.DeleteApplicationMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteApplication.t.Fatal("No results are set for the PostgresRepoMock.DeleteApplication")
		}
		return (*mm_results).err
	}
	if mmDeleteApplication.funcDeleteApplication != nil {
		return mmDeleteApplication.funcDeleteApplication(ctx, id)
	}
	mmDeleteApplication.t.Fatalf("Unexpected call to PostgresRepoMock.DeleteApplication. %v %v", ctx, id)
	return
}

// DeleteApplicationAfterCounter returns a count of finished PostgresRepoMock.DeleteApplication invocations
func (mmDeleteApplication *PostgresRepoMock) DeleteApplicationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApplication.afterDeleteApplicationCounter)
}

// DeleteApplicationBeforeCounter returns a count of PostgresRepoMock.DeleteApplication invocations
func (mmDeleteApplication *PostgresRepoMock) DeleteApplicationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApplication.beforeDeleteApplicationCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.DeleteApplication.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteApplication *mPostgresRepoMockDeleteApplication) Calls() []*PostgresRepoMockDeleteApplicationParams {
	mmDeleteApplication.mutex.RLock()

	argCopy := make([]*PostgresRepoMockDeleteApplicationParams, len(mmDeleteApplication.callArgs))
	copy(argCopy, mmDeleteApplication.callArgs)

	mmDeleteApplication.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteApplicationDone returns true if the count of the DeleteApplication invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockDeleteApplicationDone() bool {
	if m.DeleteApplicationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteApplicationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteApplicationMock.invocationsDone()
}

// MinimockDeleteApplicationInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockDeleteApplicationInspect() {
	for _, e := range m.DeleteApplicationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.DeleteApplication at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteApplicationCounter := mm_atomic.LoadUint64(&m.afterDeleteApplicationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteApplicationMock.defaultExpectation != nil && afterDeleteApplicationCounter < 1 {
		if m.DeleteApplicationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.DeleteApplication at\n%s", m.DeleteApplicationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.DeleteApplication at\n%s with params: %#v", m.DeleteApplicationMock.defaultExpectation.expectationOrigins.origin, *m.DeleteApplicationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteApplication != nil && afterDeleteApplicationCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.DeleteApplication at\n%s", m.funcDeleteApplicationOrigin)
	}

	if !m.DeleteApplicationMock.invocationsDone() && afterDeleteApplicationCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.DeleteApplication at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteApplicationMock.expectedInvocations), m.DeleteApplicationMock.expectedInvocationsOrigin, afterDeleteApplicationCounter)
	}
}

type mPostgresRepoMockDeleteApplicationProfile struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockDeleteApplicationProfileExpectation
	expectations       []*PostgresRepoMockDeleteApplicationProfileExpectation

	callArgs []*PostgresRepoMockDeleteApplicationProfileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockDeleteApplicationProfileExpectation specifies expectation struct of the PostgresRepo.DeleteApplicationProfile
type PostgresRepoMockDeleteApplicationProfileExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockDeleteApplicationProfileParams
	paramPtrs          *PostgresRepoMockDeleteApplicationProfileParamPtrs
	expectationOrigins PostgresRepoMockDeleteApplicationProfileExpectationOrigins
	results            *PostgresRepoMockDeleteApplicationProfileResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockDeleteApplicationProfileParams contains parameters of the PostgresRepo.DeleteApplicationProfile
type PostgresRepoMockDeleteApplicationProfileParams struct {
	ctx context.Context
	id  uuid.UUID
}

// PostgresRepoMockDeleteApplicationProfileParamPtrs contains pointers to parameters of the PostgresRepo.DeleteApplicationProfile
type PostgresRepoMockDeleteApplicationProfileParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// PostgresRepoMockDeleteApplicationProfileResults contains results of the PostgresRepo.DeleteApplicationProfile
type PostgresRepoMockDeleteApplicationProfileResults struct {
	err error
}

// PostgresRepoMockDeleteApplicationProfileOrigins contains origins of expectations of the PostgresRepo.DeleteApplicationProfile
type PostgresRepoMockDeleteApplicationProfileExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) Optional() *mPostgresRepoMockDeleteApplicationProfile {
	mmDeleteApplicationProfile.optional = true
	return mmDeleteApplicationProfile
}

// Expect sets up expected params for PostgresRepo.DeleteApplicationProfile
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) Expect(ctx context.Context, id uuid.UUID) *mPostgresRepoMockDeleteApplicationProfile {
	if mmDeleteApplicationProfile.mock.funcDeleteApplicationProfile != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("PostgresRepoMock.DeleteApplicationProfile mock is already set by Set")
	}

	if mmDeleteApplicationProfile.defaultExpectation == nil {
		mmDeleteApplicationProfile.defaultExpectation = &PostgresRepoMockDeleteApplicationProfileExpectation{}
	}

	if mmDeleteApplicationProfile.defaultExpectation.paramPtrs != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("PostgresRepoMock.DeleteApplicationProfile mock is already set by ExpectParams functions")
	}

	mmDeleteApplicationProfile.defaultExpectation.params = &PostgresRepoMockDeleteApplicationProfileParams{ctx, id}
	mmDeleteApplicationProfile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteApplicationProfile.expectations {
		if minimock.Equal(e.params, mmDeleteApplicationProfile.defaultExpectation.params) {
			mmDeleteApplicationProfile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteApplicationProfile.defaultExpectation.params)
		}
	}

	return mmDeleteApplicationProfile
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.DeleteApplicationProfile
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockDeleteApplicationProfile {
	if mmDeleteApplicationProfile.mock.funcDeleteApplicationProfile != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("PostgresRepoMock.DeleteApplicationProfile mock is already set by Set")
	}

	if mmDeleteApplicationProfile.defaultExpectation == nil {
		mmDeleteApplicationProfile.defaultExpectation = &PostgresRepoMockDeleteApplicationProfileExpectation{}
	}

	if mmDeleteApplicationProfile.defaultExpectation.params != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("PostgresRepoMock.DeleteApplicationProfile mock is already set by Expect")
	}

	if mmDeleteApplicationProfile.defaultExpectation.paramPtrs == nil {
		mmDeleteApplicationProfile.defaultExpectation.paramPtrs = &PostgresRepoMockDeleteApplicationProfileParamPtrs{}
	}
	mmDeleteApplicationProfile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteApplicationProfile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteApplicationProfile
}

// ExpectIdParam2 sets up expected param id for PostgresRepo.DeleteApplicationProfile
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) ExpectIdParam2(id uuid.UUID) *mPostgresRepoMockDeleteApplicationProfile {
	if mmDeleteApplicationProfile.mock.funcDeleteApplicationProfile != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("PostgresRepoMock.DeleteApplicationProfile mock is already set by Set")
	}

	if mmDeleteApplicationProfile.defaultExpectation == nil {
		mmDeleteApplicationProfile.defaultExpectation = &PostgresRepoMockDeleteApplicationProfileExpectation{}
	}

	if mmDeleteApplicationProfile.defaultExpectation.params != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("PostgresRepoMock.DeleteApplicationProfile mock is already set by Expect")
	}

	if mmDeleteApplicationProfile.defaultExpectation.paramPtrs == nil {
		mmDeleteApplicationProfile.defaultExpectation.paramPtrs = &PostgresRepoMockDeleteApplicationProfileParamPtrs{}
	}
	mmDeleteApplicationProfile.defaultExpectation.paramPtrs.id = &id
	mmDeleteApplicationProfile.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteApplicationProfile
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.DeleteApplicationProfile
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) Inspect(f func(ctx context.Context, id uuid.UUID)) *mPostgresRepoMockDeleteApplicationProfile {
	if mmDeleteApplicationProfile.mock.inspectFuncDeleteApplicationProfile != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.DeleteApplicationProfile")
	}

	mmDeleteApplicationProfile.mock.inspectFuncDeleteApplicationProfile = f

	return mmDeleteApplicationProfile
}

// Return sets up results that will be returned by PostgresRepo.DeleteApplicationProfile
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) Return(err error) *PostgresRepoMock {
	if mmDeleteApplicationProfile.mock.funcDeleteApplicationProfile != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("PostgresRepoMock.DeleteApplicationProfile mock is already set by Set")
	}

	if mmDeleteApplicationProfile.defaultExpectation == nil {
		mmDeleteApplicationProfile.defaultExpectation = &PostgresRepoMockDeleteApplicationProfileExpectation{mock: mmDeleteApplicationProfile.mock}
	}
	mmDeleteApplicationProfile.defaultExpectation.results = &PostgresRepoMockDeleteApplicationProfileResults{err}
	mmDeleteApplicationProfile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteApplicationProfile.mock
}

// Set uses given function f to mock the PostgresRepo.DeleteApplicationProfile method
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *PostgresRepoMock {
	if mmDeleteApplicationProfile.defaultExpectation != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.DeleteApplicationProfile method")
	}

	if len(mmDeleteApplicationProfile.expectations) > 0 {
		mmDeleteApplicationProfile.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.DeleteApplicationProfile method")
	}

	mmDeleteApplicationProfile.mock.funcDeleteApplicationProfile = f
	mmDeleteApplicationProfile.mock.funcDeleteApplicationProfileOrigin = minimock.CallerInfo(1)
	return mmDeleteApplicationProfile.mock
}

// When sets expectation for the PostgresRepo.DeleteApplicationProfile which will trigger the result defined by the following
// Then helper
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) When(ctx context.Context, id uuid.UUID) *PostgresRepoMockDeleteApplicationProfileExpectation {
	if mmDeleteApplicationProfile.mock.funcDeleteApplicationProfile != nil {
		mmDeleteApplicationProfile.mock.t.Fatalf("PostgresRepoMock.DeleteApplicationProfile mock is already set by Set")
	}

	expectation := &PostgresRepoMockDeleteApplicationProfileExpectation{
		mock:               mmDeleteApplicationProfile.mock,
		params:             &PostgresRepoMockDeleteApplicationProfileParams{ctx, id},
		expectationOrigins: PostgresRepoMockDeleteApplicationProfileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteApplicationProfile.expectations = append(mmDeleteApplicationProfile.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.DeleteApplicationProfile return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockDeleteApplicationProfileExpectation) Then(err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockDeleteApplicationProfileResults{err}
	return e.mock
}

// Times sets number of times PostgresRepo.DeleteApplicationProfile should be invoked
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) Times(n uint64) *mPostgresRepoMockDeleteApplicationProfile {
	if n == 0 {
		mmDeleteApplicationProfile.mock.t.Fatalf("Times of PostgresRepoMock.DeleteApplicationProfile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteApplicationProfile.expectedInvocations, n)
	mmDeleteApplicationProfile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteApplicationProfile
}

func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) invocationsDone() bool {
	if len(mmDeleteApplicationProfile.expectations) == 0 && mmDeleteApplicationProfile.defaultExpectation == nil && mmDeleteApplicationProfile.mock.funcDeleteApplicationProfile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteApplicationProfile.mock.afterDeleteApplicationProfileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteApplicationProfile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteApplicationProfile implements mm_usecase.PostgresRepo
func (mmDeleteApplicationProfile *PostgresRepoMock) DeleteApplicationProfile(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteApplicationProfile.beforeDeleteApplicationProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteApplicationProfile.afterDeleteApplicationProfileCounter, 1)

	mmDeleteApplicationProfile.t.Helper()

	if mmDeleteApplicationProfile.inspectFuncDeleteApplicationProfile != nil {
		mmDeleteApplicationProfile.inspectFuncDeleteApplicationProfile(ctx, id)
	}

	mm_params := PostgresRepoMockDeleteApplicationProfileParams{ctx, id}

	// Record call args
	mmDeleteApplicationProfile.DeleteApplicationProfileMock.mutex.Lock()
	mmDeleteApplicationProfile.DeleteApplicationProfileMock.callArgs = append(mmDeleteApplicationProfile.DeleteApplicationProfileMock.callArgs, &mm_params)
	mmDeleteApplicationProfile.DeleteApplicationProfileMock.mutex.Unlock()

	for _, e := range mmDeleteApplicationProfile.DeleteApplicationProfileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteApplicationProfile.DeleteApplicationProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteApplicationProfile.DeleteApplicationProfileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteApplicationProfile.DeleteApplicationProfileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteApplicationProfile.DeleteApplicationProfileMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockDeleteApplicationProfileParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteApplicationProfile.t.Errorf("PostgresRepoMock.DeleteApplicationProfile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteApplicationProfile.DeleteApplicationProfileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteApplicationProfile.t.Errorf("PostgresRepoMock.DeleteApplicationProfile got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteApplicationProfile.DeleteApplicationProfileMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteApplicationProfile.t.Errorf("PostgresRepoMock.DeleteApplicationProfile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteApplicationProfile.DeleteApplicationProfileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteApplicationProfile.DeleteApplicationProfileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteApplicationProfile.t.Fatal("No results are set for the PostgresRepoMock.DeleteApplicationProfile")
		}
		return (*mm_results).err
	}
	if mmDeleteApplicationProfile.funcDeleteApplicationProfile != nil {
		return mmDeleteApplicationProfile.funcDeleteApplicationProfile(ctx, id)
	}
	mmDeleteApplicationProfile.t.Fatalf("Unexpected call to PostgresRepoMock.DeleteApplicationProfile. %v %v", ctx, id)
	return
}

// DeleteApplicationProfileAfterCounter returns a count of finished PostgresRepoMock.DeleteApplicationProfile invocations
func (mmDeleteApplicationProfile *PostgresRepoMock) DeleteApplicationProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApplicationProfile.afterDeleteApplicationProfileCounter)
}

// DeleteApplicationProfileBeforeCounter returns a count of PostgresRepoMock.DeleteApplicationProfile invocations
func (mmDeleteApplicationProfile *PostgresRepoMock) DeleteApplicationProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApplicationProfile.beforeDeleteApplicationProfileCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.DeleteApplicationProfile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteApplicationProfile *mPostgresRepoMockDeleteApplicationProfile) Calls() []*PostgresRepoMockDeleteApplicationProfileParams {
	mmDeleteApplicationProfile.mutex.RLock()

	argCopy := make([]*PostgresRepoMockDeleteApplicationProfileParams, len(mmDeleteApplicationProfile.callArgs))
	copy(argCopy, mmDeleteApplicationProfile.callArgs)

	mmDeleteApplicationProfile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteApplicationProfileDone returns true if the count of the DeleteApplicationProfile invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockDeleteApplicationProfileDone() bool {
	if m.DeleteApplicationProfileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteApplicationProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteApplicationProfileMock.invocationsDone()
}

// MinimockDeleteApplicationProfileInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockDeleteApplicationProfileInspect() {
	for _, e := range m.DeleteApplicationProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.DeleteApplicationProfile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteApplicationProfileCounter := mm_atomic.LoadUint64(&m.afterDeleteApplicationProfileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteApplicationProfileMock.defaultExpectation != nil && afterDeleteApplicationProfileCounter < 1 {
		if m.DeleteApplicationProfileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.DeleteApplicationProfile at\n%s", m.DeleteApplicationProfileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.DeleteApplicationProfile at\n%s with params: %#v", m.DeleteApplicationProfileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteApplicationProfileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteApplicationProfile != nil && afterDeleteApplicationProfileCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.DeleteApplicationProfile at\n%s", m.funcDeleteApplicationProfileOrigin)
	}

	if !m.DeleteApplicationProfileMock.invocationsDone() && afterDeleteApplicationProfileCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.DeleteApplicationProfile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteApplicationProfileMock.expectedInvocations), m.DeleteApplicationProfileMock.expectedInvocationsOrigin, afterDeleteApplicationProfileCounter)
	}
}

type mPostgresRepoMockGetApplication struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockGetApplicationExpectation
	expectations       []*PostgresRepoMockGetApplicationExpectation

	callArgs []*PostgresRepoMockGetApplicationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockGetApplicationExpectation specifies expectation struct of the PostgresRepo.GetApplication
type PostgresRepoMockGetApplicationExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockGetApplicationParams
	paramPtrs          *PostgresRepoMockGetApplicationParamPtrs
	expectationOrigins PostgresRepoMockGetApplicationExpectationOrigins
	results            *PostgresRepoMockGetApplicationResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockGetApplicationParams contains parameters of the PostgresRepo.GetApplication
type PostgresRepoMockGetApplicationParams struct {
	ctx context.Context
	id  uuid.UUID
}

// PostgresRepoMockGetApplicationParamPtrs contains pointers to parameters of the PostgresRepo.GetApplication
type PostgresRepoMockGetApplicationParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// PostgresRepoMockGetApplicationResults contains results of the PostgresRepo.GetApplication
type PostgresRepoMockGetApplicationResults struct {
	ap1 *entity.Application
	err error
}

// PostgresRepoMockGetApplicationOrigins contains origins of expectations of the PostgresRepo.GetApplication
type PostgresRepoMockGetApplicationExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApplication *mPostgresRepoMockGetApplication) Optional() *mPostgresRepoMockGetApplication {
	mmGetApplication.optional = true
	return mmGetApplication
}

// Expect sets up expected params for PostgresRepo.GetApplication
func (mmGetApplication *mPostgresRepoMockGetApplication) Expect(ctx context.Context, id uuid.UUID) *mPostgresRepoMockGetApplication {
	if mmGetApplication.mock.funcGetApplication != nil {
		mmGetApplication.mock.t.Fatalf("PostgresRepoMock.GetApplication mock is already set by Set")
	}

	if mmGetApplication.defaultExpectation == nil {
		mmGetApplication.defaultExpectation = &PostgresRepoMockGetApplicationExpectation{}
	}

	if mmGetApplication.defaultExpectation.paramPtrs != nil {
		mmGetApplication.mock.t.Fatalf("PostgresRepoMock.GetApplication mock is already set by ExpectParams functions")
	}

	mmGetApplication.defaultExpectation.params = &PostgresRepoMockGetApplicationParams{ctx, id}
	mmGetApplication.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetApplication.expectations {
		if minimock.Equal(e.params, mmGetApplication.defaultExpectation.params) {
			mmGetApplication.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApplication.defaultExpectation.params)
		}
	}

	return mmGetApplication
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.GetApplication
func (mmGetApplication *mPostgresRepoMockGetApplication) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockGetApplication {
	if mmGetApplication.mock.funcGetApplication != nil {
		mmGetApplication.mock.t.Fatalf("PostgresRepoMock.GetApplication mock is already set by Set")
	}

	if mmGetApplication.defaultExpectation == nil {
		mmGetApplication.defaultExpectation = &PostgresRepoMockGetApplicationExpectation{}
	}

	if mmGetApplication.defaultExpectation.params != nil {
		mmGetApplication.mock.t.Fatalf("PostgresRepoMock.GetApplication mock is already set by Expect")
	}

	if mmGetApplication.defaultExpectation.paramPtrs == nil {
		mmGetApplication.defaultExpectation.paramPtrs = &PostgresRepoMockGetApplicationParamPtrs{}
	}
	mmGetApplication.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetApplication.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetApplication
}

// ExpectIdParam2 sets up expected param id for PostgresRepo.GetApplication
func (mmGetApplication *mPostgresRepoMockGetApplication) ExpectIdParam2(id uuid.UUID) *mPostgresRepoMockGetApplication {
	if mmGetApplication.mock.funcGetApplication != nil {
		mmGetApplication.mock.t.Fatalf("PostgresRepoMock.GetApplication mock is already set by Set")
	}

	if mmGetApplication.defaultExpectation == nil {
		mmGetApplication.defaultExpectation = &PostgresRepoMockGetApplicationExpectation{}
	}

	if mmGetApplication.defaultExpectation.params != nil {
		mmGetApplication.mock.t.Fatalf("PostgresRepoMock.GetApplication mock is already set by Expect")
	}

	if mmGetApplication.defaultExpectation.paramPtrs == nil {
		mmGetApplication.defaultExpectation.paramPtrs = &PostgresRepoMockGetApplicationParamPtrs{}
	}
	mmGetApplication.defaultExpectation.paramPtrs.id = &id
	mmGetApplication.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetApplication
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.GetApplication
func (mmGetApplication *mPostgresRepoMockGetApplication) Inspect(f func(ctx context.Context, id uuid.UUID)) *mPostgresRepoMockGetApplication {
	if mmGetApplication.mock.inspectFuncGetApplication != nil {
		mmGetApplication.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.GetApplication")
	}

	mmGetApplication.mock.inspectFuncGetApplication = f

	return mmGetApplication
}

// Return sets up results that will be returned by PostgresRepo.GetApplication
func (mmGetApplication *mPostgresRepoMockGetApplication) Return(ap1 *entity.Application, err error) *PostgresRepoMock {
	if mmGetApplication.mock.funcGetApplication != nil {
		mmGetApplication.mock.t.Fatalf("PostgresRepoMock.GetApplication mock is already set by Set")
	}

	if mmGetApplication.defaultExpectation == nil {
		mmGetApplication.defaultExpectation = &PostgresRepoMockGetApplicationExpectation{mock: mmGetApplication.mock}
	}
	mmGetApplication.defaultExpectation.results = &PostgresRepoMockGetApplicationResults{ap1, err}
	mmGetApplication.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetApplication.mock
}

// Set uses given function f to mock the PostgresRepo.GetApplication method
func (mmGetApplication *mPostgresRepoMockGetApplication) Set(f func(ctx context.Context, id uuid.UUID) (ap1 *entity.Application, err error)) *PostgresRepoMock {
	if mmGetApplication.defaultExpectation != nil {
		mmGetApplication.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.GetApplication method")
	}

	if len(mmGetApplication.expectations) > 0 {
		mmGetApplication.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.GetApplication method")
	}

	mmGetApplication.mock.funcGetApplication = f
	mmGetApplication.mock.funcGetApplicationOrigin = minimock.CallerInfo(1)
	return mmGetApplication.mock
}

// When sets expectation for the PostgresRepo.GetApplication which will trigger the result defined by the following
// Then helper
func (mmGetApplication *mPostgresRepoMockGetApplication) When(ctx context.Context, id uuid.UUID) *PostgresRepoMockGetApplicationExpectation {
	if mmGetApplication.mock.funcGetApplication != nil {
		mmGetApplication.mock.t.Fatalf("PostgresRepoMock.GetApplication mock is already set by Set")
	}

	expectation := &PostgresRepoMockGetApplicationExpectation{
		mock:               mmGetApplication.mock,
		params:             &PostgresRepoMockGetApplicationParams{ctx, id},
		expectationOrigins: PostgresRepoMockGetApplicationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetApplication.expectations = append(mmGetApplication.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.GetApplication return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockGetApplicationExpectation) Then(ap1 *entity.Application, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockGetApplicationResults{ap1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.GetApplication should be invoked
func (mmGetApplication *mPostgresRepoMockGetApplication) Times(n uint64) *mPostgresRepoMockGetApplication {
	if n == 0 {
		mmGetApplication.mock.t.Fatalf("Times of PostgresRepoMock.GetApplication mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApplication.expectedInvocations, n)
	mmGetApplication.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetApplication
}

func (mmGetApplication *mPostgresRepoMockGetApplication) invocationsDone() bool {
	if len(mmGetApplication.expectations) == 0 && mmGetApplication.defaultExpectation == nil && mmGetApplication.mock.funcGetApplication == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApplication.mock.afterGetApplicationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApplication.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApplication implements mm_usecase.PostgresRepo
func (mmGetApplication *PostgresRepoMock) GetApplication(ctx context.Context, id uuid.UUID) (ap1 *entity.Application, err error) {
	mm_atomic.AddUint64(&mmGetApplication.beforeGetApplicationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApplication.afterGetApplicationCounter, 1)

	mmGetApplication.t.Helper()

	if mmGetApplication.inspectFuncGetApplication != nil {
		mmGetApplication.inspectFuncGetApplication(ctx, id)
	}

	mm_params := PostgresRepoMockGetApplicationParams{ctx, id}

	// Record call args
	mmGetApplication.GetApplicationMock.mutex.Lock()
	mmGetApplication.GetApplicationMock.callArgs = append(mmGetApplication.GetApplicationMock.callArgs, &mm_params)
	mmGetApplication.GetApplicationMock.mutex.Unlock()

	for _, e := range mmGetApplication.GetApplicationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetApplication.GetApplicationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApplication.GetApplicationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApplication.GetApplicationMock.defaultExpectation.params
		mm_want_ptrs := mmGetApplication.GetApplicationMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockGetApplicationParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApplication.t.Errorf("PostgresRepoMock.GetApplication got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApplication.GetApplicationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetApplication.t.Errorf("PostgresRepoMock.GetApplication got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApplication.GetApplicationMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApplication.t.Errorf("PostgresRepoMock.GetApplication got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetApplication.GetApplicationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApplication.GetApplicationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApplication.t.Fatal("No results are set for the PostgresRepoMock.GetApplication")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetApplication.funcGetApplication != nil {
		return mmGetApplication.funcGetApplication(ctx, id)
	}
	mmGetApplication.t.Fatalf("Unexpected call to PostgresRepoMock.GetApplication. %v %v", ctx, id)
	return
}

// GetApplicationAfterCounter returns a count of finished PostgresRepoMock.GetApplication invocations
func (mmGetApplication *PostgresRepoMock) GetApplicationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApplication.afterGetApplicationCounter)
}

// GetApplicationBeforeCounter returns a count of PostgresRepoMock.GetApplication invocations
func (mmGetApplication *PostgresRepoMock) GetApplicationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApplication.beforeGetApplicationCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.GetApplication.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApplication *mPostgresRepoMockGetApplication) Calls() []*PostgresRepoMockGetApplicationParams {
	mmGetApplication.mutex.RLock()

	argCopy := make([]*PostgresRepoMockGetApplicationParams, len(mmGetApplication.callArgs))
	copy(argCopy, mmGetApplication.callArgs)

	mmGetApplication.mutex.RUnlock()

	return argCopy
}

// MinimockGetApplicationDone returns true if the count of the GetApplication invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockGetApplicationDone() bool {
	if m.GetApplicationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApplicationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApplicationMock.invocationsDone()
}

// MinimockGetApplicationInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockGetApplicationInspect() {
	for _, e := range m.GetApplicationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplication at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetApplicationCounter := mm_atomic.LoadUint64(&m.afterGetApplicationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApplicationMock.defaultExpectation != nil && afterGetApplicationCounter < 1 {
		if m.GetApplicationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplication at\n%s", m.GetApplicationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplication at\n%s with params: %#v", m.GetApplicationMock.defaultExpectation.expectationOrigins.origin, *m.GetApplicationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApplication != nil && afterGetApplicationCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.GetApplication at\n%s", m.funcGetApplicationOrigin)
	}

	if !m.GetApplicationMock.invocationsDone() && afterGetApplicationCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.GetApplication at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetApplicationMock.expectedInvocations), m.GetApplicationMock.expectedInvocationsOrigin, afterGetApplicationCounter)
	}
}

type mPostgresRepoMockGetApplicationProfileByID struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockGetApplicationProfileByIDExpectation
	expectations       []*PostgresRepoMockGetApplicationProfileByIDExpectation

	callArgs []*PostgresRepoMockGetApplicationProfileByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockGetApplicationProfileByIDExpectation specifies expectation struct of the PostgresRepo.GetApplicationProfileByID
type PostgresRepoMockGetApplicationProfileByIDExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockGetApplicationProfileByIDParams
	paramPtrs          *PostgresRepoMockGetApplicationProfileByIDParamPtrs
	expectationOrigins PostgresRepoMockGetApplicationProfileByIDExpectationOrigins
	results            *PostgresRepoMockGetApplicationProfileByIDResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockGetApplicationProfileByIDParams contains parameters of the PostgresRepo.GetApplicationProfileByID
type PostgresRepoMockGetApplicationProfileByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// PostgresRepoMockGetApplicationProfileByIDParamPtrs contains pointers to parameters of the PostgresRepo.GetApplicationProfileByID
type PostgresRepoMockGetApplicationProfileByIDParamPtrs struct {
	ctx *context.Context
	id  *uuid.UUID
}

// PostgresRepoMockGetApplicationProfileByIDResults contains results of the PostgresRepo.GetApplicationProfileByID
type PostgresRepoMockGetApplicationProfileByIDResults struct {
	ap1 *entity.ApplicationProfile
	err error
}

// PostgresRepoMockGetApplicationProfileByIDOrigins contains origins of expectations of the PostgresRepo.GetApplicationProfileByID
type PostgresRepoMockGetApplicationProfileByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) Optional() *mPostgresRepoMockGetApplicationProfileByID {
	mmGetApplicationProfileByID.optional = true
	return mmGetApplicationProfileByID
}

// Expect sets up expected params for PostgresRepo.GetApplicationProfileByID
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) Expect(ctx context.Context, id uuid.UUID) *mPostgresRepoMockGetApplicationProfileByID {
	if mmGetApplicationProfileByID.mock.funcGetApplicationProfileByID != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByID mock is already set by Set")
	}

	if mmGetApplicationProfileByID.defaultExpectation == nil {
		mmGetApplicationProfileByID.defaultExpectation = &PostgresRepoMockGetApplicationProfileByIDExpectation{}
	}

	if mmGetApplicationProfileByID.defaultExpectation.paramPtrs != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByID mock is already set by ExpectParams functions")
	}

	mmGetApplicationProfileByID.defaultExpectation.params = &PostgresRepoMockGetApplicationProfileByIDParams{ctx, id}
	mmGetApplicationProfileByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetApplicationProfileByID.expectations {
		if minimock.Equal(e.params, mmGetApplicationProfileByID.defaultExpectation.params) {
			mmGetApplicationProfileByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApplicationProfileByID.defaultExpectation.params)
		}
	}

	return mmGetApplicationProfileByID
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.GetApplicationProfileByID
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockGetApplicationProfileByID {
	if mmGetApplicationProfileByID.mock.funcGetApplicationProfileByID != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByID mock is already set by Set")
	}

	if mmGetApplicationProfileByID.defaultExpectation == nil {
		mmGetApplicationProfileByID.defaultExpectation = &PostgresRepoMockGetApplicationProfileByIDExpectation{}
	}

	if mmGetApplicationProfileByID.defaultExpectation.params != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByID mock is already set by Expect")
	}

	if mmGetApplicationProfileByID.defaultExpectation.paramPtrs == nil {
		mmGetApplicationProfileByID.defaultExpectation.paramPtrs = &PostgresRepoMockGetApplicationProfileByIDParamPtrs{}
	}
	mmGetApplicationProfileByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetApplicationProfileByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetApplicationProfileByID
}

// ExpectIdParam2 sets up expected param id for PostgresRepo.GetApplicationProfileByID
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) ExpectIdParam2(id uuid.UUID) *mPostgresRepoMockGetApplicationProfileByID {
	if mmGetApplicationProfileByID.mock.funcGetApplicationProfileByID != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByID mock is already set by Set")
	}

	if mmGetApplicationProfileByID.defaultExpectation == nil {
		mmGetApplicationProfileByID.defaultExpectation = &PostgresRepoMockGetApplicationProfileByIDExpectation{}
	}

	if mmGetApplicationProfileByID.defaultExpectation.params != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByID mock is already set by Expect")
	}

	if mmGetApplicationProfileByID.defaultExpectation.paramPtrs == nil {
		mmGetApplicationProfileByID.defaultExpectation.paramPtrs = &PostgresRepoMockGetApplicationProfileByIDParamPtrs{}
	}
	mmGetApplicationProfileByID.defaultExpectation.paramPtrs.id = &id
	mmGetApplicationProfileByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetApplicationProfileByID
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.GetApplicationProfileByID
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mPostgresRepoMockGetApplicationProfileByID {
	if mmGetApplicationProfileByID.mock.inspectFuncGetApplicationProfileByID != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.GetApplicationProfileByID")
	}

	mmGetApplicationProfileByID.mock.inspectFuncGetApplicationProfileByID = f

	return mmGetApplicationProfileByID
}

// Return sets up results that will be returned by PostgresRepo.GetApplicationProfileByID
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) Return(ap1 *entity.ApplicationProfile, err error) *PostgresRepoMock {
	if mmGetApplicationProfileByID.mock.funcGetApplicationProfileByID != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByID mock is already set by Set")
	}

	if mmGetApplicationProfileByID.defaultExpectation == nil {
		mmGetApplicationProfileByID.defaultExpectation = &PostgresRepoMockGetApplicationProfileByIDExpectation{mock: mmGetApplicationProfileByID.mock}
	}
	mmGetApplicationProfileByID.defaultExpectation.results = &PostgresRepoMockGetApplicationProfileByIDResults{ap1, err}
	mmGetApplicationProfileByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetApplicationProfileByID.mock
}

// Set uses given function f to mock the PostgresRepo.GetApplicationProfileByID method
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) Set(f func(ctx context.Context, id uuid.UUID) (ap1 *entity.ApplicationProfile, err error)) *PostgresRepoMock {
	if mmGetApplicationProfileByID.defaultExpectation != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.GetApplicationProfileByID method")
	}

	if len(mmGetApplicationProfileByID.expectations) > 0 {
		mmGetApplicationProfileByID.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.GetApplicationProfileByID method")
	}

	mmGetApplicationProfileByID.mock.funcGetApplicationProfileByID = f
	mmGetApplicationProfileByID.mock.funcGetApplicationProfileByIDOrigin = minimock.CallerInfo(1)
	return mmGetApplicationProfileByID.mock
}

// When sets expectation for the PostgresRepo.GetApplicationProfileByID which will trigger the result defined by the following
// Then helper
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) When(ctx context.Context, id uuid.UUID) *PostgresRepoMockGetApplicationProfileByIDExpectation {
	if mmGetApplicationProfileByID.mock.funcGetApplicationProfileByID != nil {
		mmGetApplicationProfileByID.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByID mock is already set by Set")
	}

	expectation := &PostgresRepoMockGetApplicationProfileByIDExpectation{
		mock:               mmGetApplicationProfileByID.mock,
		params:             &PostgresRepoMockGetApplicationProfileByIDParams{ctx, id},
		expectationOrigins: PostgresRepoMockGetApplicationProfileByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetApplicationProfileByID.expectations = append(mmGetApplicationProfileByID.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.GetApplicationProfileByID return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockGetApplicationProfileByIDExpectation) Then(ap1 *entity.ApplicationProfile, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockGetApplicationProfileByIDResults{ap1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.GetApplicationProfileByID should be invoked
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) Times(n uint64) *mPostgresRepoMockGetApplicationProfileByID {
	if n == 0 {
		mmGetApplicationProfileByID.mock.t.Fatalf("Times of PostgresRepoMock.GetApplicationProfileByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApplicationProfileByID.expectedInvocations, n)
	mmGetApplicationProfileByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetApplicationProfileByID
}

func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) invocationsDone() bool {
	if len(mmGetApplicationProfileByID.expectations) == 0 && mmGetApplicationProfileByID.defaultExpectation == nil && mmGetApplicationProfileByID.mock.funcGetApplicationProfileByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApplicationProfileByID.mock.afterGetApplicationProfileByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApplicationProfileByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApplicationProfileByID implements mm_usecase.PostgresRepo
func (mmGetApplicationProfileByID *PostgresRepoMock) GetApplicationProfileByID(ctx context.Context, id uuid.UUID) (ap1 *entity.ApplicationProfile, err error) {
	mm_atomic.AddUint64(&mmGetApplicationProfileByID.beforeGetApplicationProfileByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApplicationProfileByID.afterGetApplicationProfileByIDCounter, 1)

	mmGetApplicationProfileByID.t.Helper()

	if mmGetApplicationProfileByID.inspectFuncGetApplicationProfileByID != nil {
		mmGetApplicationProfileByID.inspectFuncGetApplicationProfileByID(ctx, id)
	}

	mm_params := PostgresRepoMockGetApplicationProfileByIDParams{ctx, id}

	// Record call args
	mmGetApplicationProfileByID.GetApplicationProfileByIDMock.mutex.Lock()
	mmGetApplicationProfileByID.GetApplicationProfileByIDMock.callArgs = append(mmGetApplicationProfileByID.GetApplicationProfileByIDMock.callArgs, &mm_params)
	mmGetApplicationProfileByID.GetApplicationProfileByIDMock.mutex.Unlock()

	for _, e := range mmGetApplicationProfileByID.GetApplicationProfileByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetApplicationProfileByID.GetApplicationProfileByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApplicationProfileByID.GetApplicationProfileByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApplicationProfileByID.GetApplicationProfileByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetApplicationProfileByID.GetApplicationProfileByIDMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockGetApplicationProfileByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApplicationProfileByID.t.Errorf("PostgresRepoMock.GetApplicationProfileByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApplicationProfileByID.GetApplicationProfileByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetApplicationProfileByID.t.Errorf("PostgresRepoMock.GetApplicationProfileByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApplicationProfileByID.GetApplicationProfileByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApplicationProfileByID.t.Errorf("PostgresRepoMock.GetApplicationProfileByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetApplicationProfileByID.GetApplicationProfileByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApplicationProfileByID.GetApplicationProfileByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApplicationProfileByID.t.Fatal("No results are set for the PostgresRepoMock.GetApplicationProfileByID")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetApplicationProfileByID.funcGetApplicationProfileByID != nil {
		return mmGetApplicationProfileByID.funcGetApplicationProfileByID(ctx, id)
	}
	mmGetApplicationProfileByID.t.Fatalf("Unexpected call to PostgresRepoMock.GetApplicationProfileByID. %v %v", ctx, id)
	return
}

// GetApplicationProfileByIDAfterCounter returns a count of finished PostgresRepoMock.GetApplicationProfileByID invocations
func (mmGetApplicationProfileByID *PostgresRepoMock) GetApplicationProfileByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApplicationProfileByID.afterGetApplicationProfileByIDCounter)
}

// GetApplicationProfileByIDBeforeCounter returns a count of PostgresRepoMock.GetApplicationProfileByID invocations
func (mmGetApplicationProfileByID *PostgresRepoMock) GetApplicationProfileByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApplicationProfileByID.beforeGetApplicationProfileByIDCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.GetApplicationProfileByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApplicationProfileByID *mPostgresRepoMockGetApplicationProfileByID) Calls() []*PostgresRepoMockGetApplicationProfileByIDParams {
	mmGetApplicationProfileByID.mutex.RLock()

	argCopy := make([]*PostgresRepoMockGetApplicationProfileByIDParams, len(mmGetApplicationProfileByID.callArgs))
	copy(argCopy, mmGetApplicationProfileByID.callArgs)

	mmGetApplicationProfileByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetApplicationProfileByIDDone returns true if the count of the GetApplicationProfileByID invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockGetApplicationProfileByIDDone() bool {
	if m.GetApplicationProfileByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApplicationProfileByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApplicationProfileByIDMock.invocationsDone()
}

// MinimockGetApplicationProfileByIDInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockGetApplicationProfileByIDInspect() {
	for _, e := range m.GetApplicationProfileByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplicationProfileByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetApplicationProfileByIDCounter := mm_atomic.LoadUint64(&m.afterGetApplicationProfileByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApplicationProfileByIDMock.defaultExpectation != nil && afterGetApplicationProfileByIDCounter < 1 {
		if m.GetApplicationProfileByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplicationProfileByID at\n%s", m.GetApplicationProfileByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplicationProfileByID at\n%s with params: %#v", m.GetApplicationProfileByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetApplicationProfileByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApplicationProfileByID != nil && afterGetApplicationProfileByIDCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.GetApplicationProfileByID at\n%s", m.funcGetApplicationProfileByIDOrigin)
	}

	if !m.GetApplicationProfileByIDMock.invocationsDone() && afterGetApplicationProfileByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.GetApplicationProfileByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetApplicationProfileByIDMock.expectedInvocations), m.GetApplicationProfileByIDMock.expectedInvocationsOrigin, afterGetApplicationProfileByIDCounter)
	}
}

type mPostgresRepoMockGetApplicationProfileByVersion struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockGetApplicationProfileByVersionExpectation
	expectations       []*PostgresRepoMockGetApplicationProfileByVersionExpectation

	callArgs []*PostgresRepoMockGetApplicationProfileByVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockGetApplicationProfileByVersionExpectation specifies expectation struct of the PostgresRepo.GetApplicationProfileByVersion
type PostgresRepoMockGetApplicationProfileByVersionExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockGetApplicationProfileByVersionParams
	paramPtrs          *PostgresRepoMockGetApplicationProfileByVersionParamPtrs
	expectationOrigins PostgresRepoMockGetApplicationProfileByVersionExpectationOrigins
	results            *PostgresRepoMockGetApplicationProfileByVersionResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockGetApplicationProfileByVersionParams contains parameters of the PostgresRepo.GetApplicationProfileByVersion
type PostgresRepoMockGetApplicationProfileByVersionParams struct {
	ctx           context.Context
	applicationID uuid.UUID
	version       uint32
}

// PostgresRepoMockGetApplicationProfileByVersionParamPtrs contains pointers to parameters of the PostgresRepo.GetApplicationProfileByVersion
type PostgresRepoMockGetApplicationProfileByVersionParamPtrs struct {
	ctx           *context.Context
	applicationID *uuid.UUID
	version       *uint32
}

// PostgresRepoMockGetApplicationProfileByVersionResults contains results of the PostgresRepo.GetApplicationProfileByVersion
type PostgresRepoMockGetApplicationProfileByVersionResults struct {
	ap1 *entity.ApplicationProfile
	err error
}

// PostgresRepoMockGetApplicationProfileByVersionOrigins contains origins of expectations of the PostgresRepo.GetApplicationProfileByVersion
type PostgresRepoMockGetApplicationProfileByVersionExpectationOrigins struct {
	origin              string
	originCtx           string
	originApplicationID string
	originVersion       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) Optional() *mPostgresRepoMockGetApplicationProfileByVersion {
	mmGetApplicationProfileByVersion.optional = true
	return mmGetApplicationProfileByVersion
}

// Expect sets up expected params for PostgresRepo.GetApplicationProfileByVersion
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) Expect(ctx context.Context, applicationID uuid.UUID, version uint32) *mPostgresRepoMockGetApplicationProfileByVersion {
	if mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersion != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Set")
	}

	if mmGetApplicationProfileByVersion.defaultExpectation == nil {
		mmGetApplicationProfileByVersion.defaultExpectation = &PostgresRepoMockGetApplicationProfileByVersionExpectation{}
	}

	if mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by ExpectParams functions")
	}

	mmGetApplicationProfileByVersion.defaultExpectation.params = &PostgresRepoMockGetApplicationProfileByVersionParams{ctx, applicationID, version}
	mmGetApplicationProfileByVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetApplicationProfileByVersion.expectations {
		if minimock.Equal(e.params, mmGetApplicationProfileByVersion.defaultExpectation.params) {
			mmGetApplicationProfileByVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApplicationProfileByVersion.defaultExpectation.params)
		}
	}

	return mmGetApplicationProfileByVersion
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.GetApplicationProfileByVersion
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockGetApplicationProfileByVersion {
	if mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersion != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Set")
	}

	if mmGetApplicationProfileByVersion.defaultExpectation == nil {
		mmGetApplicationProfileByVersion.defaultExpectation = &PostgresRepoMockGetApplicationProfileByVersionExpectation{}
	}

	if mmGetApplicationProfileByVersion.defaultExpectation.params != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Expect")
	}

	if mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs == nil {
		mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs = &PostgresRepoMockGetApplicationProfileByVersionParamPtrs{}
	}
	mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetApplicationProfileByVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetApplicationProfileByVersion
}

// ExpectApplicationIDParam2 sets up expected param applicationID for PostgresRepo.GetApplicationProfileByVersion
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) ExpectApplicationIDParam2(applicationID uuid.UUID) *mPostgresRepoMockGetApplicationProfileByVersion {
	if mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersion != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Set")
	}

	if mmGetApplicationProfileByVersion.defaultExpectation == nil {
		mmGetApplicationProfileByVersion.defaultExpectation = &PostgresRepoMockGetApplicationProfileByVersionExpectation{}
	}

	if mmGetApplicationProfileByVersion.defaultExpectation.params != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Expect")
	}

	if mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs == nil {
		mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs = &PostgresRepoMockGetApplicationProfileByVersionParamPtrs{}
	}
	mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs.applicationID = &applicationID
	mmGetApplicationProfileByVersion.defaultExpectation.expectationOrigins.originApplicationID = minimock.CallerInfo(1)

	return mmGetApplicationProfileByVersion
}

// ExpectVersionParam3 sets up expected param version for PostgresRepo.GetApplicationProfileByVersion
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) ExpectVersionParam3(version uint32) *mPostgresRepoMockGetApplicationProfileByVersion {
	if mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersion != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Set")
	}

	if mmGetApplicationProfileByVersion.defaultExpectation == nil {
		mmGetApplicationProfileByVersion.defaultExpectation = &PostgresRepoMockGetApplicationProfileByVersionExpectation{}
	}

	if mmGetApplicationProfileByVersion.defaultExpectation.params != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Expect")
	}

	if mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs == nil {
		mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs = &PostgresRepoMockGetApplicationProfileByVersionParamPtrs{}
	}
	mmGetApplicationProfileByVersion.defaultExpectation.paramPtrs.version = &version
	mmGetApplicationProfileByVersion.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmGetApplicationProfileByVersion
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.GetApplicationProfileByVersion
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) Inspect(f func(ctx context.Context, applicationID uuid.UUID, version uint32)) *mPostgresRepoMockGetApplicationProfileByVersion {
	if mmGetApplicationProfileByVersion.mock.inspectFuncGetApplicationProfileByVersion != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.GetApplicationProfileByVersion")
	}

	mmGetApplicationProfileByVersion.mock.inspectFuncGetApplicationProfileByVersion = f

	return mmGetApplicationProfileByVersion
}

// Return sets up results that will be returned by PostgresRepo.GetApplicationProfileByVersion
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) Return(ap1 *entity.ApplicationProfile, err error) *PostgresRepoMock {
	if mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersion != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Set")
	}

	if mmGetApplicationProfileByVersion.defaultExpectation == nil {
		mmGetApplicationProfileByVersion.defaultExpectation = &PostgresRepoMockGetApplicationProfileByVersionExpectation{mock: mmGetApplicationProfileByVersion.mock}
	}
	mmGetApplicationProfileByVersion.defaultExpectation.results = &PostgresRepoMockGetApplicationProfileByVersionResults{ap1, err}
	mmGetApplicationProfileByVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetApplicationProfileByVersion.mock
}

// Set uses given function f to mock the PostgresRepo.GetApplicationProfileByVersion method
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) Set(f func(ctx context.Context, applicationID uuid.UUID, version uint32) (ap1 *entity.ApplicationProfile, err error)) *PostgresRepoMock {
	if mmGetApplicationProfileByVersion.defaultExpectation != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.GetApplicationProfileByVersion method")
	}

	if len(mmGetApplicationProfileByVersion.expectations) > 0 {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.GetApplicationProfileByVersion method")
	}

	mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersion = f
	mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersionOrigin = minimock.CallerInfo(1)
	return mmGetApplicationProfileByVersion.mock
}

// When sets expectation for the PostgresRepo.GetApplicationProfileByVersion which will trigger the result defined by the following
// Then helper
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) When(ctx context.Context, applicationID uuid.UUID, version uint32) *PostgresRepoMockGetApplicationProfileByVersionExpectation {
	if mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersion != nil {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("PostgresRepoMock.GetApplicationProfileByVersion mock is already set by Set")
	}

	expectation := &PostgresRepoMockGetApplicationProfileByVersionExpectation{
		mock:               mmGetApplicationProfileByVersion.mock,
		params:             &PostgresRepoMockGetApplicationProfileByVersionParams{ctx, applicationID, version},
		expectationOrigins: PostgresRepoMockGetApplicationProfileByVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetApplicationProfileByVersion.expectations = append(mmGetApplicationProfileByVersion.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.GetApplicationProfileByVersion return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockGetApplicationProfileByVersionExpectation) Then(ap1 *entity.ApplicationProfile, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockGetApplicationProfileByVersionResults{ap1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.GetApplicationProfileByVersion should be invoked
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) Times(n uint64) *mPostgresRepoMockGetApplicationProfileByVersion {
	if n == 0 {
		mmGetApplicationProfileByVersion.mock.t.Fatalf("Times of PostgresRepoMock.GetApplicationProfileByVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetApplicationProfileByVersion.expectedInvocations, n)
	mmGetApplicationProfileByVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetApplicationProfileByVersion
}

func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) invocationsDone() bool {
	if len(mmGetApplicationProfileByVersion.expectations) == 0 && mmGetApplicationProfileByVersion.defaultExpectation == nil && mmGetApplicationProfileByVersion.mock.funcGetApplicationProfileByVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetApplicationProfileByVersion.mock.afterGetApplicationProfileByVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetApplicationProfileByVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetApplicationProfileByVersion implements mm_usecase.PostgresRepo
func (mmGetApplicationProfileByVersion *PostgresRepoMock) GetApplicationProfileByVersion(ctx context.Context, applicationID uuid.UUID, version uint32) (ap1 *entity.ApplicationProfile, err error) {
	mm_atomic.AddUint64(&mmGetApplicationProfileByVersion.beforeGetApplicationProfileByVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApplicationProfileByVersion.afterGetApplicationProfileByVersionCounter, 1)

	mmGetApplicationProfileByVersion.t.Helper()

	if mmGetApplicationProfileByVersion.inspectFuncGetApplicationProfileByVersion != nil {
		mmGetApplicationProfileByVersion.inspectFuncGetApplicationProfileByVersion(ctx, applicationID, version)
	}

	mm_params := PostgresRepoMockGetApplicationProfileByVersionParams{ctx, applicationID, version}

	// Record call args
	mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.mutex.Lock()
	mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.callArgs = append(mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.callArgs, &mm_params)
	mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.mutex.Unlock()

	for _, e := range mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation.params
		mm_want_ptrs := mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockGetApplicationProfileByVersionParams{ctx, applicationID, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetApplicationProfileByVersion.t.Errorf("PostgresRepoMock.GetApplicationProfileByVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.applicationID != nil && !minimock.Equal(*mm_want_ptrs.applicationID, mm_got.applicationID) {
				mmGetApplicationProfileByVersion.t.Errorf("PostgresRepoMock.GetApplicationProfileByVersion got unexpected parameter applicationID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation.expectationOrigins.originApplicationID, *mm_want_ptrs.applicationID, mm_got.applicationID, minimock.Diff(*mm_want_ptrs.applicationID, mm_got.applicationID))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmGetApplicationProfileByVersion.t.Errorf("PostgresRepoMock.GetApplicationProfileByVersion got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApplicationProfileByVersion.t.Errorf("PostgresRepoMock.GetApplicationProfileByVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApplicationProfileByVersion.GetApplicationProfileByVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApplicationProfileByVersion.t.Fatal("No results are set for the PostgresRepoMock.GetApplicationProfileByVersion")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetApplicationProfileByVersion.funcGetApplicationProfileByVersion != nil {
		return mmGetApplicationProfileByVersion.funcGetApplicationProfileByVersion(ctx, applicationID, version)
	}
	mmGetApplicationProfileByVersion.t.Fatalf("Unexpected call to PostgresRepoMock.GetApplicationProfileByVersion. %v %v %v", ctx, applicationID, version)
	return
}

// GetApplicationProfileByVersionAfterCounter returns a count of finished PostgresRepoMock.GetApplicationProfileByVersion invocations
func (mmGetApplicationProfileByVersion *PostgresRepoMock) GetApplicationProfileByVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApplicationProfileByVersion.afterGetApplicationProfileByVersionCounter)
}

// GetApplicationProfileByVersionBeforeCounter returns a count of PostgresRepoMock.GetApplicationProfileByVersion invocations
func (mmGetApplicationProfileByVersion *PostgresRepoMock) GetApplicationProfileByVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApplicationProfileByVersion.beforeGetApplicationProfileByVersionCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.GetApplicationProfileByVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApplicationProfileByVersion *mPostgresRepoMockGetApplicationProfileByVersion) Calls() []*PostgresRepoMockGetApplicationProfileByVersionParams {
	mmGetApplicationProfileByVersion.mutex.RLock()

	argCopy := make([]*PostgresRepoMockGetApplicationProfileByVersionParams, len(mmGetApplicationProfileByVersion.callArgs))
	copy(argCopy, mmGetApplicationProfileByVersion.callArgs)

	mmGetApplicationProfileByVersion.mutex.RUnlock()

	return argCopy
}

// MinimockGetApplicationProfileByVersionDone returns true if the count of the GetApplicationProfileByVersion invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockGetApplicationProfileByVersionDone() bool {
	if m.GetApplicationProfileByVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetApplicationProfileByVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetApplicationProfileByVersionMock.invocationsDone()
}

// MinimockGetApplicationProfileByVersionInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockGetApplicationProfileByVersionInspect() {
	for _, e := range m.GetApplicationProfileByVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplicationProfileByVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetApplicationProfileByVersionCounter := mm_atomic.LoadUint64(&m.afterGetApplicationProfileByVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetApplicationProfileByVersionMock.defaultExpectation != nil && afterGetApplicationProfileByVersionCounter < 1 {
		if m.GetApplicationProfileByVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplicationProfileByVersion at\n%s", m.GetApplicationProfileByVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.GetApplicationProfileByVersion at\n%s with params: %#v", m.GetApplicationProfileByVersionMock.defaultExpectation.expectationOrigins.origin, *m.GetApplicationProfileByVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApplicationProfileByVersion != nil && afterGetApplicationProfileByVersionCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.GetApplicationProfileByVersion at\n%s", m.funcGetApplicationProfileByVersionOrigin)
	}

	if !m.GetApplicationProfileByVersionMock.invocationsDone() && afterGetApplicationProfileByVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.GetApplicationProfileByVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetApplicationProfileByVersionMock.expectedInvocations), m.GetApplicationProfileByVersionMock.expectedInvocationsOrigin, afterGetApplicationProfileByVersionCounter)
	}
}

type mPostgresRepoMockGetLatestApplicationProfile struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockGetLatestApplicationProfileExpectation
	expectations       []*PostgresRepoMockGetLatestApplicationProfileExpectation

	callArgs []*PostgresRepoMockGetLatestApplicationProfileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockGetLatestApplicationProfileExpectation specifies expectation struct of the PostgresRepo.GetLatestApplicationProfile
type PostgresRepoMockGetLatestApplicationProfileExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockGetLatestApplicationProfileParams
	paramPtrs          *PostgresRepoMockGetLatestApplicationProfileParamPtrs
	expectationOrigins PostgresRepoMockGetLatestApplicationProfileExpectationOrigins
	results            *PostgresRepoMockGetLatestApplicationProfileResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockGetLatestApplicationProfileParams contains parameters of the PostgresRepo.GetLatestApplicationProfile
type PostgresRepoMockGetLatestApplicationProfileParams struct {
	ctx           context.Context
	applicationID uuid.UUID
}

// PostgresRepoMockGetLatestApplicationProfileParamPtrs contains pointers to parameters of the PostgresRepo.GetLatestApplicationProfile
type PostgresRepoMockGetLatestApplicationProfileParamPtrs struct {
	ctx           *context.Context
	applicationID *uuid.UUID
}

// PostgresRepoMockGetLatestApplicationProfileResults contains results of the PostgresRepo.GetLatestApplicationProfile
type PostgresRepoMockGetLatestApplicationProfileResults struct {
	ap1 *entity.ApplicationProfile
	err error
}

// PostgresRepoMockGetLatestApplicationProfileOrigins contains origins of expectations of the PostgresRepo.GetLatestApplicationProfile
type PostgresRepoMockGetLatestApplicationProfileExpectationOrigins struct {
	origin              string
	originCtx           string
	originApplicationID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) Optional() *mPostgresRepoMockGetLatestApplicationProfile {
	mmGetLatestApplicationProfile.optional = true
	return mmGetLatestApplicationProfile
}

// Expect sets up expected params for PostgresRepo.GetLatestApplicationProfile
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) Expect(ctx context.Context, applicationID uuid.UUID) *mPostgresRepoMockGetLatestApplicationProfile {
	if mmGetLatestApplicationProfile.mock.funcGetLatestApplicationProfile != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("PostgresRepoMock.GetLatestApplicationProfile mock is already set by Set")
	}

	if mmGetLatestApplicationProfile.defaultExpectation == nil {
		mmGetLatestApplicationProfile.defaultExpectation = &PostgresRepoMockGetLatestApplicationProfileExpectation{}
	}

	if mmGetLatestApplicationProfile.defaultExpectation.paramPtrs != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("PostgresRepoMock.GetLatestApplicationProfile mock is already set by ExpectParams functions")
	}

	mmGetLatestApplicationProfile.defaultExpectation.params = &PostgresRepoMockGetLatestApplicationProfileParams{ctx, applicationID}
	mmGetLatestApplicationProfile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLatestApplicationProfile.expectations {
		if minimock.Equal(e.params, mmGetLatestApplicationProfile.defaultExpectation.params) {
			mmGetLatestApplicationProfile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestApplicationProfile.defaultExpectation.params)
		}
	}

	return mmGetLatestApplicationProfile
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.GetLatestApplicationProfile
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockGetLatestApplicationProfile {
	if mmGetLatestApplicationProfile.mock.funcGetLatestApplicationProfile != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("PostgresRepoMock.GetLatestApplicationProfile mock is already set by Set")
	}

	if mmGetLatestApplicationProfile.defaultExpectation == nil {
		mmGetLatestApplicationProfile.defaultExpectation = &PostgresRepoMockGetLatestApplicationProfileExpectation{}
	}

	if mmGetLatestApplicationProfile.defaultExpectation.params != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("PostgresRepoMock.GetLatestApplicationProfile mock is already set by Expect")
	}

	if mmGetLatestApplicationProfile.defaultExpectation.paramPtrs == nil {
		mmGetLatestApplicationProfile.defaultExpectation.paramPtrs = &PostgresRepoMockGetLatestApplicationProfileParamPtrs{}
	}
	mmGetLatestApplicationProfile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLatestApplicationProfile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLatestApplicationProfile
}

// ExpectApplicationIDParam2 sets up expected param applicationID for PostgresRepo.GetLatestApplicationProfile
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) ExpectApplicationIDParam2(applicationID uuid.UUID) *mPostgresRepoMockGetLatestApplicationProfile {
	if mmGetLatestApplicationProfile.mock.funcGetLatestApplicationProfile != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("PostgresRepoMock.GetLatestApplicationProfile mock is already set by Set")
	}

	if mmGetLatestApplicationProfile.defaultExpectation == nil {
		mmGetLatestApplicationProfile.defaultExpectation = &PostgresRepoMockGetLatestApplicationProfileExpectation{}
	}

	if mmGetLatestApplicationProfile.defaultExpectation.params != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("PostgresRepoMock.GetLatestApplicationProfile mock is already set by Expect")
	}

	if mmGetLatestApplicationProfile.defaultExpectation.paramPtrs == nil {
		mmGetLatestApplicationProfile.defaultExpectation.paramPtrs = &PostgresRepoMockGetLatestApplicationProfileParamPtrs{}
	}
	mmGetLatestApplicationProfile.defaultExpectation.paramPtrs.applicationID = &applicationID
	mmGetLatestApplicationProfile.defaultExpectation.expectationOrigins.originApplicationID = minimock.CallerInfo(1)

	return mmGetLatestApplicationProfile
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.GetLatestApplicationProfile
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) Inspect(f func(ctx context.Context, applicationID uuid.UUID)) *mPostgresRepoMockGetLatestApplicationProfile {
	if mmGetLatestApplicationProfile.mock.inspectFuncGetLatestApplicationProfile != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.GetLatestApplicationProfile")
	}

	mmGetLatestApplicationProfile.mock.inspectFuncGetLatestApplicationProfile = f

	return mmGetLatestApplicationProfile
}

// Return sets up results that will be returned by PostgresRepo.GetLatestApplicationProfile
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) Return(ap1 *entity.ApplicationProfile, err error) *PostgresRepoMock {
	if mmGetLatestApplicationProfile.mock.funcGetLatestApplicationProfile != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("PostgresRepoMock.GetLatestApplicationProfile mock is already set by Set")
	}

	if mmGetLatestApplicationProfile.defaultExpectation == nil {
		mmGetLatestApplicationProfile.defaultExpectation = &PostgresRepoMockGetLatestApplicationProfileExpectation{mock: mmGetLatestApplicationProfile.mock}
	}
	mmGetLatestApplicationProfile.defaultExpectation.results = &PostgresRepoMockGetLatestApplicationProfileResults{ap1, err}
	mmGetLatestApplicationProfile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLatestApplicationProfile.mock
}

// Set uses given function f to mock the PostgresRepo.GetLatestApplicationProfile method
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) Set(f func(ctx context.Context, applicationID uuid.UUID) (ap1 *entity.ApplicationProfile, err error)) *PostgresRepoMock {
	if mmGetLatestApplicationProfile.defaultExpectation != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.GetLatestApplicationProfile method")
	}

	if len(mmGetLatestApplicationProfile.expectations) > 0 {
		mmGetLatestApplicationProfile.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.GetLatestApplicationProfile method")
	}

	mmGetLatestApplicationProfile.mock.funcGetLatestApplicationProfile = f
	mmGetLatestApplicationProfile.mock.funcGetLatestApplicationProfileOrigin = minimock.CallerInfo(1)
	return mmGetLatestApplicationProfile.mock
}

// When sets expectation for the PostgresRepo.GetLatestApplicationProfile which will trigger the result defined by the following
// Then helper
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) When(ctx context.Context, applicationID uuid.UUID) *PostgresRepoMockGetLatestApplicationProfileExpectation {
	if mmGetLatestApplicationProfile.mock.funcGetLatestApplicationProfile != nil {
		mmGetLatestApplicationProfile.mock.t.Fatalf("PostgresRepoMock.GetLatestApplicationProfile mock is already set by Set")
	}

	expectation := &PostgresRepoMockGetLatestApplicationProfileExpectation{
		mock:               mmGetLatestApplicationProfile.mock,
		params:             &PostgresRepoMockGetLatestApplicationProfileParams{ctx, applicationID},
		expectationOrigins: PostgresRepoMockGetLatestApplicationProfileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLatestApplicationProfile.expectations = append(mmGetLatestApplicationProfile.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.GetLatestApplicationProfile return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockGetLatestApplicationProfileExpectation) Then(ap1 *entity.ApplicationProfile, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockGetLatestApplicationProfileResults{ap1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.GetLatestApplicationProfile should be invoked
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) Times(n uint64) *mPostgresRepoMockGetLatestApplicationProfile {
	if n == 0 {
		mmGetLatestApplicationProfile.mock.t.Fatalf("Times of PostgresRepoMock.GetLatestApplicationProfile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestApplicationProfile.expectedInvocations, n)
	mmGetLatestApplicationProfile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLatestApplicationProfile
}

func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) invocationsDone() bool {
	if len(mmGetLatestApplicationProfile.expectations) == 0 && mmGetLatestApplicationProfile.defaultExpectation == nil && mmGetLatestApplicationProfile.mock.funcGetLatestApplicationProfile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestApplicationProfile.mock.afterGetLatestApplicationProfileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestApplicationProfile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestApplicationProfile implements mm_usecase.PostgresRepo
func (mmGetLatestApplicationProfile *PostgresRepoMock) GetLatestApplicationProfile(ctx context.Context, applicationID uuid.UUID) (ap1 *entity.ApplicationProfile, err error) {
	mm_atomic.AddUint64(&mmGetLatestApplicationProfile.beforeGetLatestApplicationProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestApplicationProfile.afterGetLatestApplicationProfileCounter, 1)

	mmGetLatestApplicationProfile.t.Helper()

	if mmGetLatestApplicationProfile.inspectFuncGetLatestApplicationProfile != nil {
		mmGetLatestApplicationProfile.inspectFuncGetLatestApplicationProfile(ctx, applicationID)
	}

	mm_params := PostgresRepoMockGetLatestApplicationProfileParams{ctx, applicationID}

	// Record call args
	mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.mutex.Lock()
	mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.callArgs = append(mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.callArgs, &mm_params)
	mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.mutex.Unlock()

	for _, e := range mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockGetLatestApplicationProfileParams{ctx, applicationID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestApplicationProfile.t.Errorf("PostgresRepoMock.GetLatestApplicationProfile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.applicationID != nil && !minimock.Equal(*mm_want_ptrs.applicationID, mm_got.applicationID) {
				mmGetLatestApplicationProfile.t.Errorf("PostgresRepoMock.GetLatestApplicationProfile got unexpected parameter applicationID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.defaultExpectation.expectationOrigins.originApplicationID, *mm_want_ptrs.applicationID, mm_got.applicationID, minimock.Diff(*mm_want_ptrs.applicationID, mm_got.applicationID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestApplicationProfile.t.Errorf("PostgresRepoMock.GetLatestApplicationProfile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestApplicationProfile.GetLatestApplicationProfileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestApplicationProfile.t.Fatal("No results are set for the PostgresRepoMock.GetLatestApplicationProfile")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetLatestApplicationProfile.funcGetLatestApplicationProfile != nil {
		return mmGetLatestApplicationProfile.funcGetLatestApplicationProfile(ctx, applicationID)
	}
	mmGetLatestApplicationProfile.t.Fatalf("Unexpected call to PostgresRepoMock.GetLatestApplicationProfile. %v %v", ctx, applicationID)
	return
}

// GetLatestApplicationProfileAfterCounter returns a count of finished PostgresRepoMock.GetLatestApplicationProfile invocations
func (mmGetLatestApplicationProfile *PostgresRepoMock) GetLatestApplicationProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestApplicationProfile.afterGetLatestApplicationProfileCounter)
}

// GetLatestApplicationProfileBeforeCounter returns a count of PostgresRepoMock.GetLatestApplicationProfile invocations
func (mmGetLatestApplicationProfile *PostgresRepoMock) GetLatestApplicationProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestApplicationProfile.beforeGetLatestApplicationProfileCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.GetLatestApplicationProfile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestApplicationProfile *mPostgresRepoMockGetLatestApplicationProfile) Calls() []*PostgresRepoMockGetLatestApplicationProfileParams {
	mmGetLatestApplicationProfile.mutex.RLock()

	argCopy := make([]*PostgresRepoMockGetLatestApplicationProfileParams, len(mmGetLatestApplicationProfile.callArgs))
	copy(argCopy, mmGetLatestApplicationProfile.callArgs)

	mmGetLatestApplicationProfile.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestApplicationProfileDone returns true if the count of the GetLatestApplicationProfile invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockGetLatestApplicationProfileDone() bool {
	if m.GetLatestApplicationProfileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestApplicationProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestApplicationProfileMock.invocationsDone()
}

// MinimockGetLatestApplicationProfileInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockGetLatestApplicationProfileInspect() {
	for _, e := range m.GetLatestApplicationProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.GetLatestApplicationProfile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLatestApplicationProfileCounter := mm_atomic.LoadUint64(&m.afterGetLatestApplicationProfileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestApplicationProfileMock.defaultExpectation != nil && afterGetLatestApplicationProfileCounter < 1 {
		if m.GetLatestApplicationProfileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.GetLatestApplicationProfile at\n%s", m.GetLatestApplicationProfileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.GetLatestApplicationProfile at\n%s with params: %#v", m.GetLatestApplicationProfileMock.defaultExpectation.expectationOrigins.origin, *m.GetLatestApplicationProfileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestApplicationProfile != nil && afterGetLatestApplicationProfileCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.GetLatestApplicationProfile at\n%s", m.funcGetLatestApplicationProfileOrigin)
	}

	if !m.GetLatestApplicationProfileMock.invocationsDone() && afterGetLatestApplicationProfileCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.GetLatestApplicationProfile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestApplicationProfileMock.expectedInvocations), m.GetLatestApplicationProfileMock.expectedInvocationsOrigin, afterGetLatestApplicationProfileCounter)
	}
}

type mPostgresRepoMockGetLatestVersionForUpdate struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockGetLatestVersionForUpdateExpectation
	expectations       []*PostgresRepoMockGetLatestVersionForUpdateExpectation

	callArgs []*PostgresRepoMockGetLatestVersionForUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockGetLatestVersionForUpdateExpectation specifies expectation struct of the PostgresRepo.GetLatestVersionForUpdate
type PostgresRepoMockGetLatestVersionForUpdateExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockGetLatestVersionForUpdateParams
	paramPtrs          *PostgresRepoMockGetLatestVersionForUpdateParamPtrs
	expectationOrigins PostgresRepoMockGetLatestVersionForUpdateExpectationOrigins
	results            *PostgresRepoMockGetLatestVersionForUpdateResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockGetLatestVersionForUpdateParams contains parameters of the PostgresRepo.GetLatestVersionForUpdate
type PostgresRepoMockGetLatestVersionForUpdateParams struct {
	ctx           context.Context
	applicationID uuid.UUID
}

// PostgresRepoMockGetLatestVersionForUpdateParamPtrs contains pointers to parameters of the PostgresRepo.GetLatestVersionForUpdate
type PostgresRepoMockGetLatestVersionForUpdateParamPtrs struct {
	ctx           *context.Context
	applicationID *uuid.UUID
}

// PostgresRepoMockGetLatestVersionForUpdateResults contains results of the PostgresRepo.GetLatestVersionForUpdate
type PostgresRepoMockGetLatestVersionForUpdateResults struct {
	u1  uint32
	err error
}

// PostgresRepoMockGetLatestVersionForUpdateOrigins contains origins of expectations of the PostgresRepo.GetLatestVersionForUpdate
type PostgresRepoMockGetLatestVersionForUpdateExpectationOrigins struct {
	origin              string
	originCtx           string
	originApplicationID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) Optional() *mPostgresRepoMockGetLatestVersionForUpdate {
	mmGetLatestVersionForUpdate.optional = true
	return mmGetLatestVersionForUpdate
}

// Expect sets up expected params for PostgresRepo.GetLatestVersionForUpdate
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) Expect(ctx context.Context, applicationID uuid.UUID) *mPostgresRepoMockGetLatestVersionForUpdate {
	if mmGetLatestVersionForUpdate.mock.funcGetLatestVersionForUpdate != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("PostgresRepoMock.GetLatestVersionForUpdate mock is already set by Set")
	}

	if mmGetLatestVersionForUpdate.defaultExpectation == nil {
		mmGetLatestVersionForUpdate.defaultExpectation = &PostgresRepoMockGetLatestVersionForUpdateExpectation{}
	}

	if mmGetLatestVersionForUpdate.defaultExpectation.paramPtrs != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("PostgresRepoMock.GetLatestVersionForUpdate mock is already set by ExpectParams functions")
	}

	mmGetLatestVersionForUpdate.defaultExpectation.params = &PostgresRepoMockGetLatestVersionForUpdateParams{ctx, applicationID}
	mmGetLatestVersionForUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLatestVersionForUpdate.expectations {
		if minimock.Equal(e.params, mmGetLatestVersionForUpdate.defaultExpectation.params) {
			mmGetLatestVersionForUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestVersionForUpdate.defaultExpectation.params)
		}
	}

	return mmGetLatestVersionForUpdate
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.GetLatestVersionForUpdate
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockGetLatestVersionForUpdate {
	if mmGetLatestVersionForUpdate.mock.funcGetLatestVersionForUpdate != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("PostgresRepoMock.GetLatestVersionForUpdate mock is already set by Set")
	}

	if mmGetLatestVersionForUpdate.defaultExpectation == nil {
		mmGetLatestVersionForUpdate.defaultExpectation = &PostgresRepoMockGetLatestVersionForUpdateExpectation{}
	}

	if mmGetLatestVersionForUpdate.defaultExpectation.params != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("PostgresRepoMock.GetLatestVersionForUpdate mock is already set by Expect")
	}

	if mmGetLatestVersionForUpdate.defaultExpectation.paramPtrs == nil {
		mmGetLatestVersionForUpdate.defaultExpectation.paramPtrs = &PostgresRepoMockGetLatestVersionForUpdateParamPtrs{}
	}
	mmGetLatestVersionForUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLatestVersionForUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLatestVersionForUpdate
}

// ExpectApplicationIDParam2 sets up expected param applicationID for PostgresRepo.GetLatestVersionForUpdate
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) ExpectApplicationIDParam2(applicationID uuid.UUID) *mPostgresRepoMockGetLatestVersionForUpdate {
	if mmGetLatestVersionForUpdate.mock.funcGetLatestVersionForUpdate != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("PostgresRepoMock.GetLatestVersionForUpdate mock is already set by Set")
	}

	if mmGetLatestVersionForUpdate.defaultExpectation == nil {
		mmGetLatestVersionForUpdate.defaultExpectation = &PostgresRepoMockGetLatestVersionForUpdateExpectation{}
	}

	if mmGetLatestVersionForUpdate.defaultExpectation.params != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("PostgresRepoMock.GetLatestVersionForUpdate mock is already set by Expect")
	}

	if mmGetLatestVersionForUpdate.defaultExpectation.paramPtrs == nil {
		mmGetLatestVersionForUpdate.defaultExpectation.paramPtrs = &PostgresRepoMockGetLatestVersionForUpdateParamPtrs{}
	}
	mmGetLatestVersionForUpdate.defaultExpectation.paramPtrs.applicationID = &applicationID
	mmGetLatestVersionForUpdate.defaultExpectation.expectationOrigins.originApplicationID = minimock.CallerInfo(1)

	return mmGetLatestVersionForUpdate
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.GetLatestVersionForUpdate
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) Inspect(f func(ctx context.Context, applicationID uuid.UUID)) *mPostgresRepoMockGetLatestVersionForUpdate {
	if mmGetLatestVersionForUpdate.mock.inspectFuncGetLatestVersionForUpdate != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.GetLatestVersionForUpdate")
	}

	mmGetLatestVersionForUpdate.mock.inspectFuncGetLatestVersionForUpdate = f

	return mmGetLatestVersionForUpdate
}

// Return sets up results that will be returned by PostgresRepo.GetLatestVersionForUpdate
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) Return(u1 uint32, err error) *PostgresRepoMock {
	if mmGetLatestVersionForUpdate.mock.funcGetLatestVersionForUpdate != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("PostgresRepoMock.GetLatestVersionForUpdate mock is already set by Set")
	}

	if mmGetLatestVersionForUpdate.defaultExpectation == nil {
		mmGetLatestVersionForUpdate.defaultExpectation = &PostgresRepoMockGetLatestVersionForUpdateExpectation{mock: mmGetLatestVersionForUpdate.mock}
	}
	mmGetLatestVersionForUpdate.defaultExpectation.results = &PostgresRepoMockGetLatestVersionForUpdateResults{u1, err}
	mmGetLatestVersionForUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLatestVersionForUpdate.mock
}

// Set uses given function f to mock the PostgresRepo.GetLatestVersionForUpdate method
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) Set(f func(ctx context.Context, applicationID uuid.UUID) (u1 uint32, err error)) *PostgresRepoMock {
	if mmGetLatestVersionForUpdate.defaultExpectation != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.GetLatestVersionForUpdate method")
	}

	if len(mmGetLatestVersionForUpdate.expectations) > 0 {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.GetLatestVersionForUpdate method")
	}

	mmGetLatestVersionForUpdate.mock.funcGetLatestVersionForUpdate = f
	mmGetLatestVersionForUpdate.mock.funcGetLatestVersionForUpdateOrigin = minimock.CallerInfo(1)
	return mmGetLatestVersionForUpdate.mock
}

// When sets expectation for the PostgresRepo.GetLatestVersionForUpdate which will trigger the result defined by the following
// Then helper
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) When(ctx context.Context, applicationID uuid.UUID) *PostgresRepoMockGetLatestVersionForUpdateExpectation {
	if mmGetLatestVersionForUpdate.mock.funcGetLatestVersionForUpdate != nil {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("PostgresRepoMock.GetLatestVersionForUpdate mock is already set by Set")
	}

	expectation := &PostgresRepoMockGetLatestVersionForUpdateExpectation{
		mock:               mmGetLatestVersionForUpdate.mock,
		params:             &PostgresRepoMockGetLatestVersionForUpdateParams{ctx, applicationID},
		expectationOrigins: PostgresRepoMockGetLatestVersionForUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLatestVersionForUpdate.expectations = append(mmGetLatestVersionForUpdate.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.GetLatestVersionForUpdate return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockGetLatestVersionForUpdateExpectation) Then(u1 uint32, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockGetLatestVersionForUpdateResults{u1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.GetLatestVersionForUpdate should be invoked
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) Times(n uint64) *mPostgresRepoMockGetLatestVersionForUpdate {
	if n == 0 {
		mmGetLatestVersionForUpdate.mock.t.Fatalf("Times of PostgresRepoMock.GetLatestVersionForUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestVersionForUpdate.expectedInvocations, n)
	mmGetLatestVersionForUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLatestVersionForUpdate
}

func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) invocationsDone() bool {
	if len(mmGetLatestVersionForUpdate.expectations) == 0 && mmGetLatestVersionForUpdate.defaultExpectation == nil && mmGetLatestVersionForUpdate.mock.funcGetLatestVersionForUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestVersionForUpdate.mock.afterGetLatestVersionForUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestVersionForUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestVersionForUpdate implements mm_usecase.PostgresRepo
func (mmGetLatestVersionForUpdate *PostgresRepoMock) GetLatestVersionForUpdate(ctx context.Context, applicationID uuid.UUID) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetLatestVersionForUpdate.beforeGetLatestVersionForUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestVersionForUpdate.afterGetLatestVersionForUpdateCounter, 1)

	mmGetLatestVersionForUpdate.t.Helper()

	if mmGetLatestVersionForUpdate.inspectFuncGetLatestVersionForUpdate != nil {
		mmGetLatestVersionForUpdate.inspectFuncGetLatestVersionForUpdate(ctx, applicationID)
	}

	mm_params := PostgresRepoMockGetLatestVersionForUpdateParams{ctx, applicationID}

	// Record call args
	mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.mutex.Lock()
	mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.callArgs = append(mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.callArgs, &mm_params)
	mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.mutex.Unlock()

	for _, e := range mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockGetLatestVersionForUpdateParams{ctx, applicationID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestVersionForUpdate.t.Errorf("PostgresRepoMock.GetLatestVersionForUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.applicationID != nil && !minimock.Equal(*mm_want_ptrs.applicationID, mm_got.applicationID) {
				mmGetLatestVersionForUpdate.t.Errorf("PostgresRepoMock.GetLatestVersionForUpdate got unexpected parameter applicationID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.defaultExpectation.expectationOrigins.originApplicationID, *mm_want_ptrs.applicationID, mm_got.applicationID, minimock.Diff(*mm_want_ptrs.applicationID, mm_got.applicationID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestVersionForUpdate.t.Errorf("PostgresRepoMock.GetLatestVersionForUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestVersionForUpdate.GetLatestVersionForUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestVersionForUpdate.t.Fatal("No results are set for the PostgresRepoMock.GetLatestVersionForUpdate")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetLatestVersionForUpdate.funcGetLatestVersionForUpdate != nil {
		return mmGetLatestVersionForUpdate.funcGetLatestVersionForUpdate(ctx, applicationID)
	}
	mmGetLatestVersionForUpdate.t.Fatalf("Unexpected call to PostgresRepoMock.GetLatestVersionForUpdate. %v %v", ctx, applicationID)
	return
}

// GetLatestVersionForUpdateAfterCounter returns a count of finished PostgresRepoMock.GetLatestVersionForUpdate invocations
func (mmGetLatestVersionForUpdate *PostgresRepoMock) GetLatestVersionForUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestVersionForUpdate.afterGetLatestVersionForUpdateCounter)
}

// GetLatestVersionForUpdateBeforeCounter returns a count of PostgresRepoMock.GetLatestVersionForUpdate invocations
func (mmGetLatestVersionForUpdate *PostgresRepoMock) GetLatestVersionForUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestVersionForUpdate.beforeGetLatestVersionForUpdateCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.GetLatestVersionForUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestVersionForUpdate *mPostgresRepoMockGetLatestVersionForUpdate) Calls() []*PostgresRepoMockGetLatestVersionForUpdateParams {
	mmGetLatestVersionForUpdate.mutex.RLock()

	argCopy := make([]*PostgresRepoMockGetLatestVersionForUpdateParams, len(mmGetLatestVersionForUpdate.callArgs))
	copy(argCopy, mmGetLatestVersionForUpdate.callArgs)

	mmGetLatestVersionForUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestVersionForUpdateDone returns true if the count of the GetLatestVersionForUpdate invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockGetLatestVersionForUpdateDone() bool {
	if m.GetLatestVersionForUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestVersionForUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestVersionForUpdateMock.invocationsDone()
}

// MinimockGetLatestVersionForUpdateInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockGetLatestVersionForUpdateInspect() {
	for _, e := range m.GetLatestVersionForUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.GetLatestVersionForUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLatestVersionForUpdateCounter := mm_atomic.LoadUint64(&m.afterGetLatestVersionForUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestVersionForUpdateMock.defaultExpectation != nil && afterGetLatestVersionForUpdateCounter < 1 {
		if m.GetLatestVersionForUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.GetLatestVersionForUpdate at\n%s", m.GetLatestVersionForUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.GetLatestVersionForUpdate at\n%s with params: %#v", m.GetLatestVersionForUpdateMock.defaultExpectation.expectationOrigins.origin, *m.GetLatestVersionForUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestVersionForUpdate != nil && afterGetLatestVersionForUpdateCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.GetLatestVersionForUpdate at\n%s", m.funcGetLatestVersionForUpdateOrigin)
	}

	if !m.GetLatestVersionForUpdateMock.invocationsDone() && afterGetLatestVersionForUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.GetLatestVersionForUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestVersionForUpdateMock.expectedInvocations), m.GetLatestVersionForUpdateMock.expectedInvocationsOrigin, afterGetLatestVersionForUpdateCounter)
	}
}

type mPostgresRepoMockListApplicationProfiles struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockListApplicationProfilesExpectation
	expectations       []*PostgresRepoMockListApplicationProfilesExpectation

	callArgs []*PostgresRepoMockListApplicationProfilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockListApplicationProfilesExpectation specifies expectation struct of the PostgresRepo.ListApplicationProfiles
type PostgresRepoMockListApplicationProfilesExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockListApplicationProfilesParams
	paramPtrs          *PostgresRepoMockListApplicationProfilesParamPtrs
	expectationOrigins PostgresRepoMockListApplicationProfilesExpectationOrigins
	results            *PostgresRepoMockListApplicationProfilesResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockListApplicationProfilesParams contains parameters of the PostgresRepo.ListApplicationProfiles
type PostgresRepoMockListApplicationProfilesParams struct {
	ctx           context.Context
	applicationID uuid.UUID
}

// PostgresRepoMockListApplicationProfilesParamPtrs contains pointers to parameters of the PostgresRepo.ListApplicationProfiles
type PostgresRepoMockListApplicationProfilesParamPtrs struct {
	ctx           *context.Context
	applicationID *uuid.UUID
}

// PostgresRepoMockListApplicationProfilesResults contains results of the PostgresRepo.ListApplicationProfiles
type PostgresRepoMockListApplicationProfilesResults struct {
	apa1 []*entity.ApplicationProfile
	err  error
}

// PostgresRepoMockListApplicationProfilesOrigins contains origins of expectations of the PostgresRepo.ListApplicationProfiles
type PostgresRepoMockListApplicationProfilesExpectationOrigins struct {
	origin              string
	originCtx           string
	originApplicationID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) Optional() *mPostgresRepoMockListApplicationProfiles {
	mmListApplicationProfiles.optional = true
	return mmListApplicationProfiles
}

// Expect sets up expected params for PostgresRepo.ListApplicationProfiles
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) Expect(ctx context.Context, applicationID uuid.UUID) *mPostgresRepoMockListApplicationProfiles {
	if mmListApplicationProfiles.mock.funcListApplicationProfiles != nil {
		mmListApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListApplicationProfiles mock is already set by Set")
	}

	if mmListApplicationProfiles.defaultExpectation == nil {
		mmListApplicationProfiles.defaultExpectation = &PostgresRepoMockListApplicationProfilesExpectation{}
	}

	if mmListApplicationProfiles.defaultExpectation.paramPtrs != nil {
		mmListApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListApplicationProfiles mock is already set by ExpectParams functions")
	}

	mmListApplicationProfiles.defaultExpectation.params = &PostgresRepoMockListApplicationProfilesParams{ctx, applicationID}
	mmListApplicationProfiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListApplicationProfiles.expectations {
		if minimock.Equal(e.params, mmListApplicationProfiles.defaultExpectation.params) {
			mmListApplicationProfiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListApplicationProfiles.defaultExpectation.params)
		}
	}

	return mmListApplicationProfiles
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.ListApplicationProfiles
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockListApplicationProfiles {
	if mmListApplicationProfiles.mock.funcListApplicationProfiles != nil {
		mmListApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListApplicationProfiles mock is already set by Set")
	}

	if mmListApplicationProfiles.defaultExpectation == nil {
		mmListApplicationProfiles.defaultExpectation = &PostgresRepoMockListApplicationProfilesExpectation{}
	}

	if mmListApplicationProfiles.defaultExpectation.params != nil {
		mmListApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListApplicationProfiles mock is already set by Expect")
	}

	if mmListApplicationProfiles.defaultExpectation.paramPtrs == nil {
		mmListApplicationProfiles.defaultExpectation.paramPtrs = &PostgresRepoMockListApplicationProfilesParamPtrs{}
	}
	mmListApplicationProfiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListApplicationProfiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListApplicationProfiles
}

// ExpectApplicationIDParam2 sets up expected param applicationID for PostgresRepo.ListApplicationProfiles
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) ExpectApplicationIDParam2(applicationID uuid.UUID) *mPostgresRepoMockListApplicationProfiles {
	if mmListApplicationProfiles.mock.funcListApplicationProfiles != nil {
		mmListApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListApplicationProfiles mock is already set by Set")
	}

	if mmListApplicationProfiles.defaultExpectation == nil {
		mmListApplicationProfiles.defaultExpectation = &PostgresRepoMockListApplicationProfilesExpectation{}
	}

	if mmListApplicationProfiles.defaultExpectation.params != nil {
		mmListApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListApplicationProfiles mock is already set by Expect")
	}

	if mmListApplicationProfiles.defaultExpectation.paramPtrs == nil {
		mmListApplicationProfiles.defaultExpectation.paramPtrs = &PostgresRepoMockListApplicationProfilesParamPtrs{}
	}
	mmListApplicationProfiles.defaultExpectation.paramPtrs.applicationID = &applicationID
	mmListApplicationProfiles.defaultExpectation.expectationOrigins.originApplicationID = minimock.CallerInfo(1)

	return mmListApplicationProfiles
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.ListApplicationProfiles
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) Inspect(f func(ctx context.Context, applicationID uuid.UUID)) *mPostgresRepoMockListApplicationProfiles {
	if mmListApplicationProfiles.mock.inspectFuncListApplicationProfiles != nil {
		mmListApplicationProfiles.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.ListApplicationProfiles")
	}

	mmListApplicationProfiles.mock.inspectFuncListApplicationProfiles = f

	return mmListApplicationProfiles
}

// Return sets up results that will be returned by PostgresRepo.ListApplicationProfiles
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) Return(apa1 []*entity.ApplicationProfile, err error) *PostgresRepoMock {
	if mmListApplicationProfiles.mock.funcListApplicationProfiles != nil {
		mmListApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListApplicationProfiles mock is already set by Set")
	}

	if mmListApplicationProfiles.defaultExpectation == nil {
		mmListApplicationProfiles.defaultExpectation = &PostgresRepoMockListApplicationProfilesExpectation{mock: mmListApplicationProfiles.mock}
	}
	mmListApplicationProfiles.defaultExpectation.results = &PostgresRepoMockListApplicationProfilesResults{apa1, err}
	mmListApplicationProfiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListApplicationProfiles.mock
}

// Set uses given function f to mock the PostgresRepo.ListApplicationProfiles method
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) Set(f func(ctx context.Context, applicationID uuid.UUID) (apa1 []*entity.ApplicationProfile, err error)) *PostgresRepoMock {
	if mmListApplicationProfiles.defaultExpectation != nil {
		mmListApplicationProfiles.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.ListApplicationProfiles method")
	}

	if len(mmListApplicationProfiles.expectations) > 0 {
		mmListApplicationProfiles.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.ListApplicationProfiles method")
	}

	mmListApplicationProfiles.mock.funcListApplicationProfiles = f
	mmListApplicationProfiles.mock.funcListApplicationProfilesOrigin = minimock.CallerInfo(1)
	return mmListApplicationProfiles.mock
}

// When sets expectation for the PostgresRepo.ListApplicationProfiles which will trigger the result defined by the following
// Then helper
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) When(ctx context.Context, applicationID uuid.UUID) *PostgresRepoMockListApplicationProfilesExpectation {
	if mmListApplicationProfiles.mock.funcListApplicationProfiles != nil {
		mmListApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListApplicationProfiles mock is already set by Set")
	}

	expectation := &PostgresRepoMockListApplicationProfilesExpectation{
		mock:               mmListApplicationProfiles.mock,
		params:             &PostgresRepoMockListApplicationProfilesParams{ctx, applicationID},
		expectationOrigins: PostgresRepoMockListApplicationProfilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListApplicationProfiles.expectations = append(mmListApplicationProfiles.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.ListApplicationProfiles return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockListApplicationProfilesExpectation) Then(apa1 []*entity.ApplicationProfile, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockListApplicationProfilesResults{apa1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.ListApplicationProfiles should be invoked
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) Times(n uint64) *mPostgresRepoMockListApplicationProfiles {
	if n == 0 {
		mmListApplicationProfiles.mock.t.Fatalf("Times of PostgresRepoMock.ListApplicationProfiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListApplicationProfiles.expectedInvocations, n)
	mmListApplicationProfiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListApplicationProfiles
}

func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) invocationsDone() bool {
	if len(mmListApplicationProfiles.expectations) == 0 && mmListApplicationProfiles.defaultExpectation == nil && mmListApplicationProfiles.mock.funcListApplicationProfiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListApplicationProfiles.mock.afterListApplicationProfilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListApplicationProfiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListApplicationProfiles implements mm_usecase.PostgresRepo
func (mmListApplicationProfiles *PostgresRepoMock) ListApplicationProfiles(ctx context.Context, applicationID uuid.UUID) (apa1 []*entity.ApplicationProfile, err error) {
	mm_atomic.AddUint64(&mmListApplicationProfiles.beforeListApplicationProfilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListApplicationProfiles.afterListApplicationProfilesCounter, 1)

	mmListApplicationProfiles.t.Helper()

	if mmListApplicationProfiles.inspectFuncListApplicationProfiles != nil {
		mmListApplicationProfiles.inspectFuncListApplicationProfiles(ctx, applicationID)
	}

	mm_params := PostgresRepoMockListApplicationProfilesParams{ctx, applicationID}

	// Record call args
	mmListApplicationProfiles.ListApplicationProfilesMock.mutex.Lock()
	mmListApplicationProfiles.ListApplicationProfilesMock.callArgs = append(mmListApplicationProfiles.ListApplicationProfilesMock.callArgs, &mm_params)
	mmListApplicationProfiles.ListApplicationProfilesMock.mutex.Unlock()

	for _, e := range mmListApplicationProfiles.ListApplicationProfilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmListApplicationProfiles.ListApplicationProfilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListApplicationProfiles.ListApplicationProfilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListApplicationProfiles.ListApplicationProfilesMock.defaultExpectation.params
		mm_want_ptrs := mmListApplicationProfiles.ListApplicationProfilesMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockListApplicationProfilesParams{ctx, applicationID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListApplicationProfiles.t.Errorf("PostgresRepoMock.ListApplicationProfiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListApplicationProfiles.ListApplicationProfilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.applicationID != nil && !minimock.Equal(*mm_want_ptrs.applicationID, mm_got.applicationID) {
				mmListApplicationProfiles.t.Errorf("PostgresRepoMock.ListApplicationProfiles got unexpected parameter applicationID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListApplicationProfiles.ListApplicationProfilesMock.defaultExpectation.expectationOrigins.originApplicationID, *mm_want_ptrs.applicationID, mm_got.applicationID, minimock.Diff(*mm_want_ptrs.applicationID, mm_got.applicationID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListApplicationProfiles.t.Errorf("PostgresRepoMock.ListApplicationProfiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListApplicationProfiles.ListApplicationProfilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListApplicationProfiles.ListApplicationProfilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListApplicationProfiles.t.Fatal("No results are set for the PostgresRepoMock.ListApplicationProfiles")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmListApplicationProfiles.funcListApplicationProfiles != nil {
		return mmListApplicationProfiles.funcListApplicationProfiles(ctx, applicationID)
	}
	mmListApplicationProfiles.t.Fatalf("Unexpected call to PostgresRepoMock.ListApplicationProfiles. %v %v", ctx, applicationID)
	return
}

// ListApplicationProfilesAfterCounter returns a count of finished PostgresRepoMock.ListApplicationProfiles invocations
func (mmListApplicationProfiles *PostgresRepoMock) ListApplicationProfilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListApplicationProfiles.afterListApplicationProfilesCounter)
}

// ListApplicationProfilesBeforeCounter returns a count of PostgresRepoMock.ListApplicationProfiles invocations
func (mmListApplicationProfiles *PostgresRepoMock) ListApplicationProfilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListApplicationProfiles.beforeListApplicationProfilesCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.ListApplicationProfiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListApplicationProfiles *mPostgresRepoMockListApplicationProfiles) Calls() []*PostgresRepoMockListApplicationProfilesParams {
	mmListApplicationProfiles.mutex.RLock()

	argCopy := make([]*PostgresRepoMockListApplicationProfilesParams, len(mmListApplicationProfiles.callArgs))
	copy(argCopy, mmListApplicationProfiles.callArgs)

	mmListApplicationProfiles.mutex.RUnlock()

	return argCopy
}

// MinimockListApplicationProfilesDone returns true if the count of the ListApplicationProfiles invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockListApplicationProfilesDone() bool {
	if m.ListApplicationProfilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListApplicationProfilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListApplicationProfilesMock.invocationsDone()
}

// MinimockListApplicationProfilesInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockListApplicationProfilesInspect() {
	for _, e := range m.ListApplicationProfilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.ListApplicationProfiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListApplicationProfilesCounter := mm_atomic.LoadUint64(&m.afterListApplicationProfilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListApplicationProfilesMock.defaultExpectation != nil && afterListApplicationProfilesCounter < 1 {
		if m.ListApplicationProfilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.ListApplicationProfiles at\n%s", m.ListApplicationProfilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.ListApplicationProfiles at\n%s with params: %#v", m.ListApplicationProfilesMock.defaultExpectation.expectationOrigins.origin, *m.ListApplicationProfilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListApplicationProfiles != nil && afterListApplicationProfilesCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.ListApplicationProfiles at\n%s", m.funcListApplicationProfilesOrigin)
	}

	if !m.ListApplicationProfilesMock.invocationsDone() && afterListApplicationProfilesCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.ListApplicationProfiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListApplicationProfilesMock.expectedInvocations), m.ListApplicationProfilesMock.expectedInvocationsOrigin, afterListApplicationProfilesCounter)
	}
}

type mPostgresRepoMockListApplications struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockListApplicationsExpectation
	expectations       []*PostgresRepoMockListApplicationsExpectation

	callArgs []*PostgresRepoMockListApplicationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockListApplicationsExpectation specifies expectation struct of the PostgresRepo.ListApplications
type PostgresRepoMockListApplicationsExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockListApplicationsParams
	paramPtrs          *PostgresRepoMockListApplicationsParamPtrs
	expectationOrigins PostgresRepoMockListApplicationsExpectationOrigins
	results            *PostgresRepoMockListApplicationsResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockListApplicationsParams contains parameters of the PostgresRepo.ListApplications
type PostgresRepoMockListApplicationsParams struct {
	ctx context.Context
}

// PostgresRepoMockListApplicationsParamPtrs contains pointers to parameters of the PostgresRepo.ListApplications
type PostgresRepoMockListApplicationsParamPtrs struct {
	ctx *context.Context
}

// PostgresRepoMockListApplicationsResults contains results of the PostgresRepo.ListApplications
type PostgresRepoMockListApplicationsResults struct {
	apa1 []*entity.Application
	err  error
}

// PostgresRepoMockListApplicationsOrigins contains origins of expectations of the PostgresRepo.ListApplications
type PostgresRepoMockListApplicationsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListApplications *mPostgresRepoMockListApplications) Optional() *mPostgresRepoMockListApplications {
	mmListApplications.optional = true
	return mmListApplications
}

// Expect sets up expected params for PostgresRepo.ListApplications
func (mmListApplications *mPostgresRepoMockListApplications) Expect(ctx context.Context) *mPostgresRepoMockListApplications {
	if mmListApplications.mock.funcListApplications != nil {
		mmListApplications.mock.t.Fatalf("PostgresRepoMock.ListApplications mock is already set by Set")
	}

	if mmListApplications.defaultExpectation == nil {
		mmListApplications.defaultExpectation = &PostgresRepoMockListApplicationsExpectation{}
	}

	if mmListApplications.defaultExpectation.paramPtrs != nil {
		mmListApplications.mock.t.Fatalf("PostgresRepoMock.ListApplications mock is already set by ExpectParams functions")
	}

	mmListApplications.defaultExpectation.params = &PostgresRepoMockListApplicationsParams{ctx}
	mmListApplications.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListApplications.expectations {
		if minimock.Equal(e.params, mmListApplications.defaultExpectation.params) {
			mmListApplications.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListApplications.defaultExpectation.params)
		}
	}

	return mmListApplications
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.ListApplications
func (mmListApplications *mPostgresRepoMockListApplications) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockListApplications {
	if mmListApplications.mock.funcListApplications != nil {
		mmListApplications.mock.t.Fatalf("PostgresRepoMock.ListApplications mock is already set by Set")
	}

	if mmListApplications.defaultExpectation == nil {
		mmListApplications.defaultExpectation = &PostgresRepoMockListApplicationsExpectation{}
	}

	if mmListApplications.defaultExpectation.params != nil {
		mmListApplications.mock.t.Fatalf("PostgresRepoMock.ListApplications mock is already set by Expect")
	}

	if mmListApplications.defaultExpectation.paramPtrs == nil {
		mmListApplications.defaultExpectation.paramPtrs = &PostgresRepoMockListApplicationsParamPtrs{}
	}
	mmListApplications.defaultExpectation.paramPtrs.ctx = &ctx
	mmListApplications.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListApplications
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.ListApplications
func (mmListApplications *mPostgresRepoMockListApplications) Inspect(f func(ctx context.Context)) *mPostgresRepoMockListApplications {
	if mmListApplications.mock.inspectFuncListApplications != nil {
		mmListApplications.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.ListApplications")
	}

	mmListApplications.mock.inspectFuncListApplications = f

	return mmListApplications
}

// Return sets up results that will be returned by PostgresRepo.ListApplications
func (mmListApplications *mPostgresRepoMockListApplications) Return(apa1 []*entity.Application, err error) *PostgresRepoMock {
	if mmListApplications.mock.funcListApplications != nil {
		mmListApplications.mock.t.Fatalf("PostgresRepoMock.ListApplications mock is already set by Set")
	}

	if mmListApplications.defaultExpectation == nil {
		mmListApplications.defaultExpectation = &PostgresRepoMockListApplicationsExpectation{mock: mmListApplications.mock}
	}
	mmListApplications.defaultExpectation.results = &PostgresRepoMockListApplicationsResults{apa1, err}
	mmListApplications.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListApplications.mock
}

// Set uses given function f to mock the PostgresRepo.ListApplications method
func (mmListApplications *mPostgresRepoMockListApplications) Set(f func(ctx context.Context) (apa1 []*entity.Application, err error)) *PostgresRepoMock {
	if mmListApplications.defaultExpectation != nil {
		mmListApplications.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.ListApplications method")
	}

	if len(mmListApplications.expectations) > 0 {
		mmListApplications.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.ListApplications method")
	}

	mmListApplications.mock.funcListApplications = f
	mmListApplications.mock.funcListApplicationsOrigin = minimock.CallerInfo(1)
	return mmListApplications.mock
}

// When sets expectation for the PostgresRepo.ListApplications which will trigger the result defined by the following
// Then helper
func (mmListApplications *mPostgresRepoMockListApplications) When(ctx context.Context) *PostgresRepoMockListApplicationsExpectation {
	if mmListApplications.mock.funcListApplications != nil {
		mmListApplications.mock.t.Fatalf("PostgresRepoMock.ListApplications mock is already set by Set")
	}

	expectation := &PostgresRepoMockListApplicationsExpectation{
		mock:               mmListApplications.mock,
		params:             &PostgresRepoMockListApplicationsParams{ctx},
		expectationOrigins: PostgresRepoMockListApplicationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListApplications.expectations = append(mmListApplications.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.ListApplications return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockListApplicationsExpectation) Then(apa1 []*entity.Application, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockListApplicationsResults{apa1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.ListApplications should be invoked
func (mmListApplications *mPostgresRepoMockListApplications) Times(n uint64) *mPostgresRepoMockListApplications {
	if n == 0 {
		mmListApplications.mock.t.Fatalf("Times of PostgresRepoMock.ListApplications mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListApplications.expectedInvocations, n)
	mmListApplications.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListApplications
}

func (mmListApplications *mPostgresRepoMockListApplications) invocationsDone() bool {
	if len(mmListApplications.expectations) == 0 && mmListApplications.defaultExpectation == nil && mmListApplications.mock.funcListApplications == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListApplications.mock.afterListApplicationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListApplications.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListApplications implements mm_usecase.PostgresRepo
func (mmListApplications *PostgresRepoMock) ListApplications(ctx context.Context) (apa1 []*entity.Application, err error) {
	mm_atomic.AddUint64(&mmListApplications.beforeListApplicationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListApplications.afterListApplicationsCounter, 1)

	mmListApplications.t.Helper()

	if mmListApplications.inspectFuncListApplications != nil {
		mmListApplications.inspectFuncListApplications(ctx)
	}

	mm_params := PostgresRepoMockListApplicationsParams{ctx}

	// Record call args
	mmListApplications.ListApplicationsMock.mutex.Lock()
	mmListApplications.ListApplicationsMock.callArgs = append(mmListApplications.ListApplicationsMock.callArgs, &mm_params)
	mmListApplications.ListApplicationsMock.mutex.Unlock()

	for _, e := range mmListApplications.ListApplicationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmListApplications.ListApplicationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListApplications.ListApplicationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListApplications.ListApplicationsMock.defaultExpectation.params
		mm_want_ptrs := mmListApplications.ListApplicationsMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockListApplicationsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListApplications.t.Errorf("PostgresRepoMock.ListApplications got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListApplications.ListApplicationsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListApplications.t.Errorf("PostgresRepoMock.ListApplications got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListApplications.ListApplicationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListApplications.ListApplicationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListApplications.t.Fatal("No results are set for the PostgresRepoMock.ListApplications")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmListApplications.funcListApplications != nil {
		return mmListApplications.funcListApplications(ctx)
	}
	mmListApplications.t.Fatalf("Unexpected call to PostgresRepoMock.ListApplications. %v", ctx)
	return
}

// ListApplicationsAfterCounter returns a count of finished PostgresRepoMock.ListApplications invocations
func (mmListApplications *PostgresRepoMock) ListApplicationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListApplications.afterListApplicationsCounter)
}

// ListApplicationsBeforeCounter returns a count of PostgresRepoMock.ListApplications invocations
func (mmListApplications *PostgresRepoMock) ListApplicationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListApplications.beforeListApplicationsCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.ListApplications.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListApplications *mPostgresRepoMockListApplications) Calls() []*PostgresRepoMockListApplicationsParams {
	mmListApplications.mutex.RLock()

	argCopy := make([]*PostgresRepoMockListApplicationsParams, len(mmListApplications.callArgs))
	copy(argCopy, mmListApplications.callArgs)

	mmListApplications.mutex.RUnlock()

	return argCopy
}

// MinimockListApplicationsDone returns true if the count of the ListApplications invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockListApplicationsDone() bool {
	if m.ListApplicationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListApplicationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListApplicationsMock.invocationsDone()
}

// MinimockListApplicationsInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockListApplicationsInspect() {
	for _, e := range m.ListApplicationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.ListApplications at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListApplicationsCounter := mm_atomic.LoadUint64(&m.afterListApplicationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListApplicationsMock.defaultExpectation != nil && afterListApplicationsCounter < 1 {
		if m.ListApplicationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.ListApplications at\n%s", m.ListApplicationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.ListApplications at\n%s with params: %#v", m.ListApplicationsMock.defaultExpectation.expectationOrigins.origin, *m.ListApplicationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListApplications != nil && afterListApplicationsCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.ListApplications at\n%s", m.funcListApplicationsOrigin)
	}

	if !m.ListApplicationsMock.invocationsDone() && afterListApplicationsCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.ListApplications at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListApplicationsMock.expectedInvocations), m.ListApplicationsMock.expectedInvocationsOrigin, afterListApplicationsCounter)
	}
}

type mPostgresRepoMockListLatestApplicationProfiles struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockListLatestApplicationProfilesExpectation
	expectations       []*PostgresRepoMockListLatestApplicationProfilesExpectation

	callArgs []*PostgresRepoMockListLatestApplicationProfilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockListLatestApplicationProfilesExpectation specifies expectation struct of the PostgresRepo.ListLatestApplicationProfiles
type PostgresRepoMockListLatestApplicationProfilesExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockListLatestApplicationProfilesParams
	paramPtrs          *PostgresRepoMockListLatestApplicationProfilesParamPtrs
	expectationOrigins PostgresRepoMockListLatestApplicationProfilesExpectationOrigins
	results            *PostgresRepoMockListLatestApplicationProfilesResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockListLatestApplicationProfilesParams contains parameters of the PostgresRepo.ListLatestApplicationProfiles
type PostgresRepoMockListLatestApplicationProfilesParams struct {
	ctx context.Context
}

// PostgresRepoMockListLatestApplicationProfilesParamPtrs contains pointers to parameters of the PostgresRepo.ListLatestApplicationProfiles
type PostgresRepoMockListLatestApplicationProfilesParamPtrs struct {
	ctx *context.Context
}

// PostgresRepoMockListLatestApplicationProfilesResults contains results of the PostgresRepo.ListLatestApplicationProfiles
type PostgresRepoMockListLatestApplicationProfilesResults struct {
	apa1 []*entity.ApplicationProfile
	err  error
}

// PostgresRepoMockListLatestApplicationProfilesOrigins contains origins of expectations of the PostgresRepo.ListLatestApplicationProfiles
type PostgresRepoMockListLatestApplicationProfilesExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) Optional() *mPostgresRepoMockListLatestApplicationProfiles {
	mmListLatestApplicationProfiles.optional = true
	return mmListLatestApplicationProfiles
}

// Expect sets up expected params for PostgresRepo.ListLatestApplicationProfiles
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) Expect(ctx context.Context) *mPostgresRepoMockListLatestApplicationProfiles {
	if mmListLatestApplicationProfiles.mock.funcListLatestApplicationProfiles != nil {
		mmListLatestApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListLatestApplicationProfiles mock is already set by Set")
	}

	if mmListLatestApplicationProfiles.defaultExpectation == nil {
		mmListLatestApplicationProfiles.defaultExpectation = &PostgresRepoMockListLatestApplicationProfilesExpectation{}
	}

	if mmListLatestApplicationProfiles.defaultExpectation.paramPtrs != nil {
		mmListLatestApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListLatestApplicationProfiles mock is already set by ExpectParams functions")
	}

	mmListLatestApplicationProfiles.defaultExpectation.params = &PostgresRepoMockListLatestApplicationProfilesParams{ctx}
	mmListLatestApplicationProfiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListLatestApplicationProfiles.expectations {
		if minimock.Equal(e.params, mmListLatestApplicationProfiles.defaultExpectation.params) {
			mmListLatestApplicationProfiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListLatestApplicationProfiles.defaultExpectation.params)
		}
	}

	return mmListLatestApplicationProfiles
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.ListLatestApplicationProfiles
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockListLatestApplicationProfiles {
	if mmListLatestApplicationProfiles.mock.funcListLatestApplicationProfiles != nil {
		mmListLatestApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListLatestApplicationProfiles mock is already set by Set")
	}

	if mmListLatestApplicationProfiles.defaultExpectation == nil {
		mmListLatestApplicationProfiles.defaultExpectation = &PostgresRepoMockListLatestApplicationProfilesExpectation{}
	}

	if mmListLatestApplicationProfiles.defaultExpectation.params != nil {
		mmListLatestApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListLatestApplicationProfiles mock is already set by Expect")
	}

	if mmListLatestApplicationProfiles.defaultExpectation.paramPtrs == nil {
		mmListLatestApplicationProfiles.defaultExpectation.paramPtrs = &PostgresRepoMockListLatestApplicationProfilesParamPtrs{}
	}
	mmListLatestApplicationProfiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListLatestApplicationProfiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListLatestApplicationProfiles
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.ListLatestApplicationProfiles
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) Inspect(f func(ctx context.Context)) *mPostgresRepoMockListLatestApplicationProfiles {
	if mmListLatestApplicationProfiles.mock.inspectFuncListLatestApplicationProfiles != nil {
		mmListLatestApplicationProfiles.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.ListLatestApplicationProfiles")
	}

	mmListLatestApplicationProfiles.mock.inspectFuncListLatestApplicationProfiles = f

	return mmListLatestApplicationProfiles
}

// Return sets up results that will be returned by PostgresRepo.ListLatestApplicationProfiles
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) Return(apa1 []*entity.ApplicationProfile, err error) *PostgresRepoMock {
	if mmListLatestApplicationProfiles.mock.funcListLatestApplicationProfiles != nil {
		mmListLatestApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListLatestApplicationProfiles mock is already set by Set")
	}

	if mmListLatestApplicationProfiles.defaultExpectation == nil {
		mmListLatestApplicationProfiles.defaultExpectation = &PostgresRepoMockListLatestApplicationProfilesExpectation{mock: mmListLatestApplicationProfiles.mock}
	}
	mmListLatestApplicationProfiles.defaultExpectation.results = &PostgresRepoMockListLatestApplicationProfilesResults{apa1, err}
	mmListLatestApplicationProfiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListLatestApplicationProfiles.mock
}

// Set uses given function f to mock the PostgresRepo.ListLatestApplicationProfiles method
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) Set(f func(ctx context.Context) (apa1 []*entity.ApplicationProfile, err error)) *PostgresRepoMock {
	if mmListLatestApplicationProfiles.defaultExpectation != nil {
		mmListLatestApplicationProfiles.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.ListLatestApplicationProfiles method")
	}

	if len(mmListLatestApplicationProfiles.expectations) > 0 {
		mmListLatestApplicationProfiles.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.ListLatestApplicationProfiles method")
	}

	mmListLatestApplicationProfiles.mock.funcListLatestApplicationProfiles = f
	mmListLatestApplicationProfiles.mock.funcListLatestApplicationProfilesOrigin = minimock.CallerInfo(1)
	return mmListLatestApplicationProfiles.mock
}

// When sets expectation for the PostgresRepo.ListLatestApplicationProfiles which will trigger the result defined by the following
// Then helper
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) When(ctx context.Context) *PostgresRepoMockListLatestApplicationProfilesExpectation {
	if mmListLatestApplicationProfiles.mock.funcListLatestApplicationProfiles != nil {
		mmListLatestApplicationProfiles.mock.t.Fatalf("PostgresRepoMock.ListLatestApplicationProfiles mock is already set by Set")
	}

	expectation := &PostgresRepoMockListLatestApplicationProfilesExpectation{
		mock:               mmListLatestApplicationProfiles.mock,
		params:             &PostgresRepoMockListLatestApplicationProfilesParams{ctx},
		expectationOrigins: PostgresRepoMockListLatestApplicationProfilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListLatestApplicationProfiles.expectations = append(mmListLatestApplicationProfiles.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.ListLatestApplicationProfiles return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockListLatestApplicationProfilesExpectation) Then(apa1 []*entity.ApplicationProfile, err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockListLatestApplicationProfilesResults{apa1, err}
	return e.mock
}

// Times sets number of times PostgresRepo.ListLatestApplicationProfiles should be invoked
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) Times(n uint64) *mPostgresRepoMockListLatestApplicationProfiles {
	if n == 0 {
		mmListLatestApplicationProfiles.mock.t.Fatalf("Times of PostgresRepoMock.ListLatestApplicationProfiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListLatestApplicationProfiles.expectedInvocations, n)
	mmListLatestApplicationProfiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListLatestApplicationProfiles
}

func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) invocationsDone() bool {
	if len(mmListLatestApplicationProfiles.expectations) == 0 && mmListLatestApplicationProfiles.defaultExpectation == nil && mmListLatestApplicationProfiles.mock.funcListLatestApplicationProfiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListLatestApplicationProfiles.mock.afterListLatestApplicationProfilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListLatestApplicationProfiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListLatestApplicationProfiles implements mm_usecase.PostgresRepo
func (mmListLatestApplicationProfiles *PostgresRepoMock) ListLatestApplicationProfiles(ctx context.Context) (apa1 []*entity.ApplicationProfile, err error) {
	mm_atomic.AddUint64(&mmListLatestApplicationProfiles.beforeListLatestApplicationProfilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListLatestApplicationProfiles.afterListLatestApplicationProfilesCounter, 1)

	mmListLatestApplicationProfiles.t.Helper()

	if mmListLatestApplicationProfiles.inspectFuncListLatestApplicationProfiles != nil {
		mmListLatestApplicationProfiles.inspectFuncListLatestApplicationProfiles(ctx)
	}

	mm_params := PostgresRepoMockListLatestApplicationProfilesParams{ctx}

	// Record call args
	mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.mutex.Lock()
	mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.callArgs = append(mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.callArgs, &mm_params)
	mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.mutex.Unlock()

	for _, e := range mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.defaultExpectation.params
		mm_want_ptrs := mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockListLatestApplicationProfilesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListLatestApplicationProfiles.t.Errorf("PostgresRepoMock.ListLatestApplicationProfiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListLatestApplicationProfiles.t.Errorf("PostgresRepoMock.ListLatestApplicationProfiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListLatestApplicationProfiles.ListLatestApplicationProfilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListLatestApplicationProfiles.t.Fatal("No results are set for the PostgresRepoMock.ListLatestApplicationProfiles")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmListLatestApplicationProfiles.funcListLatestApplicationProfiles != nil {
		return mmListLatestApplicationProfiles.funcListLatestApplicationProfiles(ctx)
	}
	mmListLatestApplicationProfiles.t.Fatalf("Unexpected call to PostgresRepoMock.ListLatestApplicationProfiles. %v", ctx)
	return
}

// ListLatestApplicationProfilesAfterCounter returns a count of finished PostgresRepoMock.ListLatestApplicationProfiles invocations
func (mmListLatestApplicationProfiles *PostgresRepoMock) ListLatestApplicationProfilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListLatestApplicationProfiles.afterListLatestApplicationProfilesCounter)
}

// ListLatestApplicationProfilesBeforeCounter returns a count of PostgresRepoMock.ListLatestApplicationProfiles invocations
func (mmListLatestApplicationProfiles *PostgresRepoMock) ListLatestApplicationProfilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListLatestApplicationProfiles.beforeListLatestApplicationProfilesCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.ListLatestApplicationProfiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListLatestApplicationProfiles *mPostgresRepoMockListLatestApplicationProfiles) Calls() []*PostgresRepoMockListLatestApplicationProfilesParams {
	mmListLatestApplicationProfiles.mutex.RLock()

	argCopy := make([]*PostgresRepoMockListLatestApplicationProfilesParams, len(mmListLatestApplicationProfiles.callArgs))
	copy(argCopy, mmListLatestApplicationProfiles.callArgs)

	mmListLatestApplicationProfiles.mutex.RUnlock()

	return argCopy
}

// MinimockListLatestApplicationProfilesDone returns true if the count of the ListLatestApplicationProfiles invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockListLatestApplicationProfilesDone() bool {
	if m.ListLatestApplicationProfilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListLatestApplicationProfilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListLatestApplicationProfilesMock.invocationsDone()
}

// MinimockListLatestApplicationProfilesInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockListLatestApplicationProfilesInspect() {
	for _, e := range m.ListLatestApplicationProfilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.ListLatestApplicationProfiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListLatestApplicationProfilesCounter := mm_atomic.LoadUint64(&m.afterListLatestApplicationProfilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListLatestApplicationProfilesMock.defaultExpectation != nil && afterListLatestApplicationProfilesCounter < 1 {
		if m.ListLatestApplicationProfilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.ListLatestApplicationProfiles at\n%s", m.ListLatestApplicationProfilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.ListLatestApplicationProfiles at\n%s with params: %#v", m.ListLatestApplicationProfilesMock.defaultExpectation.expectationOrigins.origin, *m.ListLatestApplicationProfilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListLatestApplicationProfiles != nil && afterListLatestApplicationProfilesCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.ListLatestApplicationProfiles at\n%s", m.funcListLatestApplicationProfilesOrigin)
	}

	if !m.ListLatestApplicationProfilesMock.invocationsDone() && afterListLatestApplicationProfilesCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.ListLatestApplicationProfiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListLatestApplicationProfilesMock.expectedInvocations), m.ListLatestApplicationProfilesMock.expectedInvocationsOrigin, afterListLatestApplicationProfilesCounter)
	}
}

type mPostgresRepoMockUpdateApplication struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockUpdateApplicationExpectation
	expectations       []*PostgresRepoMockUpdateApplicationExpectation

	callArgs []*PostgresRepoMockUpdateApplicationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockUpdateApplicationExpectation specifies expectation struct of the PostgresRepo.UpdateApplication
type PostgresRepoMockUpdateApplicationExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockUpdateApplicationParams
	paramPtrs          *PostgresRepoMockUpdateApplicationParamPtrs
	expectationOrigins PostgresRepoMockUpdateApplicationExpectationOrigins
	results            *PostgresRepoMockUpdateApplicationResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockUpdateApplicationParams contains parameters of the PostgresRepo.UpdateApplication
type PostgresRepoMockUpdateApplicationParams struct {
	ctx context.Context
	app *entity.Application
	id  uuid.UUID
}

// PostgresRepoMockUpdateApplicationParamPtrs contains pointers to parameters of the PostgresRepo.UpdateApplication
type PostgresRepoMockUpdateApplicationParamPtrs struct {
	ctx *context.Context
	app **entity.Application
	id  *uuid.UUID
}

// PostgresRepoMockUpdateApplicationResults contains results of the PostgresRepo.UpdateApplication
type PostgresRepoMockUpdateApplicationResults struct {
	err error
}

// PostgresRepoMockUpdateApplicationOrigins contains origins of expectations of the PostgresRepo.UpdateApplication
type PostgresRepoMockUpdateApplicationExpectationOrigins struct {
	origin    string
	originCtx string
	originApp string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) Optional() *mPostgresRepoMockUpdateApplication {
	mmUpdateApplication.optional = true
	return mmUpdateApplication
}

// Expect sets up expected params for PostgresRepo.UpdateApplication
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) Expect(ctx context.Context, app *entity.Application, id uuid.UUID) *mPostgresRepoMockUpdateApplication {
	if mmUpdateApplication.mock.funcUpdateApplication != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Set")
	}

	if mmUpdateApplication.defaultExpectation == nil {
		mmUpdateApplication.defaultExpectation = &PostgresRepoMockUpdateApplicationExpectation{}
	}

	if mmUpdateApplication.defaultExpectation.paramPtrs != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by ExpectParams functions")
	}

	mmUpdateApplication.defaultExpectation.params = &PostgresRepoMockUpdateApplicationParams{ctx, app, id}
	mmUpdateApplication.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateApplication.expectations {
		if minimock.Equal(e.params, mmUpdateApplication.defaultExpectation.params) {
			mmUpdateApplication.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateApplication.defaultExpectation.params)
		}
	}

	return mmUpdateApplication
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.UpdateApplication
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockUpdateApplication {
	if mmUpdateApplication.mock.funcUpdateApplication != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Set")
	}

	if mmUpdateApplication.defaultExpectation == nil {
		mmUpdateApplication.defaultExpectation = &PostgresRepoMockUpdateApplicationExpectation{}
	}

	if mmUpdateApplication.defaultExpectation.params != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Expect")
	}

	if mmUpdateApplication.defaultExpectation.paramPtrs == nil {
		mmUpdateApplication.defaultExpectation.paramPtrs = &PostgresRepoMockUpdateApplicationParamPtrs{}
	}
	mmUpdateApplication.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateApplication.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateApplication
}

// ExpectAppParam2 sets up expected param app for PostgresRepo.UpdateApplication
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) ExpectAppParam2(app *entity.Application) *mPostgresRepoMockUpdateApplication {
	if mmUpdateApplication.mock.funcUpdateApplication != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Set")
	}

	if mmUpdateApplication.defaultExpectation == nil {
		mmUpdateApplication.defaultExpectation = &PostgresRepoMockUpdateApplicationExpectation{}
	}

	if mmUpdateApplication.defaultExpectation.params != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Expect")
	}

	if mmUpdateApplication.defaultExpectation.paramPtrs == nil {
		mmUpdateApplication.defaultExpectation.paramPtrs = &PostgresRepoMockUpdateApplicationParamPtrs{}
	}
	mmUpdateApplication.defaultExpectation.paramPtrs.app = &app
	mmUpdateApplication.defaultExpectation.expectationOrigins.originApp = minimock.CallerInfo(1)

	return mmUpdateApplication
}

// ExpectIdParam3 sets up expected param id for PostgresRepo.UpdateApplication
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) ExpectIdParam3(id uuid.UUID) *mPostgresRepoMockUpdateApplication {
	if mmUpdateApplication.mock.funcUpdateApplication != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Set")
	}

	if mmUpdateApplication.defaultExpectation == nil {
		mmUpdateApplication.defaultExpectation = &PostgresRepoMockUpdateApplicationExpectation{}
	}

	if mmUpdateApplication.defaultExpectation.params != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Expect")
	}

	if mmUpdateApplication.defaultExpectation.paramPtrs == nil {
		mmUpdateApplication.defaultExpectation.paramPtrs = &PostgresRepoMockUpdateApplicationParamPtrs{}
	}
	mmUpdateApplication.defaultExpectation.paramPtrs.id = &id
	mmUpdateApplication.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateApplication
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.UpdateApplication
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) Inspect(f func(ctx context.Context, app *entity.Application, id uuid.UUID)) *mPostgresRepoMockUpdateApplication {
	if mmUpdateApplication.mock.inspectFuncUpdateApplication != nil {
		mmUpdateApplication.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.UpdateApplication")
	}

	mmUpdateApplication.mock.inspectFuncUpdateApplication = f

	return mmUpdateApplication
}

// Return sets up results that will be returned by PostgresRepo.UpdateApplication
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) Return(err error) *PostgresRepoMock {
	if mmUpdateApplication.mock.funcUpdateApplication != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Set")
	}

	if mmUpdateApplication.defaultExpectation == nil {
		mmUpdateApplication.defaultExpectation = &PostgresRepoMockUpdateApplicationExpectation{mock: mmUpdateApplication.mock}
	}
	mmUpdateApplication.defaultExpectation.results = &PostgresRepoMockUpdateApplicationResults{err}
	mmUpdateApplication.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateApplication.mock
}

// Set uses given function f to mock the PostgresRepo.UpdateApplication method
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) Set(f func(ctx context.Context, app *entity.Application, id uuid.UUID) (err error)) *PostgresRepoMock {
	if mmUpdateApplication.defaultExpectation != nil {
		mmUpdateApplication.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.UpdateApplication method")
	}

	if len(mmUpdateApplication.expectations) > 0 {
		mmUpdateApplication.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.UpdateApplication method")
	}

	mmUpdateApplication.mock.funcUpdateApplication = f
	mmUpdateApplication.mock.funcUpdateApplicationOrigin = minimock.CallerInfo(1)
	return mmUpdateApplication.mock
}

// When sets expectation for the PostgresRepo.UpdateApplication which will trigger the result defined by the following
// Then helper
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) When(ctx context.Context, app *entity.Application, id uuid.UUID) *PostgresRepoMockUpdateApplicationExpectation {
	if mmUpdateApplication.mock.funcUpdateApplication != nil {
		mmUpdateApplication.mock.t.Fatalf("PostgresRepoMock.UpdateApplication mock is already set by Set")
	}

	expectation := &PostgresRepoMockUpdateApplicationExpectation{
		mock:               mmUpdateApplication.mock,
		params:             &PostgresRepoMockUpdateApplicationParams{ctx, app, id},
		expectationOrigins: PostgresRepoMockUpdateApplicationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateApplication.expectations = append(mmUpdateApplication.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.UpdateApplication return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockUpdateApplicationExpectation) Then(err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockUpdateApplicationResults{err}
	return e.mock
}

// Times sets number of times PostgresRepo.UpdateApplication should be invoked
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) Times(n uint64) *mPostgresRepoMockUpdateApplication {
	if n == 0 {
		mmUpdateApplication.mock.t.Fatalf("Times of PostgresRepoMock.UpdateApplication mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateApplication.expectedInvocations, n)
	mmUpdateApplication.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateApplication
}

func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) invocationsDone() bool {
	if len(mmUpdateApplication.expectations) == 0 && mmUpdateApplication.defaultExpectation == nil && mmUpdateApplication.mock.funcUpdateApplication == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateApplication.mock.afterUpdateApplicationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateApplication.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateApplication implements mm_usecase.PostgresRepo
func (mmUpdateApplication *PostgresRepoMock) UpdateApplication(ctx context.Context, app *entity.Application, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmUpdateApplication.beforeUpdateApplicationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateApplication.afterUpdateApplicationCounter, 1)

	mmUpdateApplication.t.Helper()

	if mmUpdateApplication.inspectFuncUpdateApplication != nil {
		mmUpdateApplication.inspectFuncUpdateApplication(ctx, app, id)
	}

	mm_params := PostgresRepoMockUpdateApplicationParams{ctx, app, id}

	// Record call args
	mmUpdateApplication.UpdateApplicationMock.mutex.Lock()
	mmUpdateApplication.UpdateApplicationMock.callArgs = append(mmUpdateApplication.UpdateApplicationMock.callArgs, &mm_params)
	mmUpdateApplication.UpdateApplicationMock.mutex.Unlock()

	for _, e := range mmUpdateApplication.UpdateApplicationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateApplication.UpdateApplicationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateApplication.UpdateApplicationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateApplication.UpdateApplicationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateApplication.UpdateApplicationMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockUpdateApplicationParams{ctx, app, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateApplication.t.Errorf("PostgresRepoMock.UpdateApplication got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateApplication.UpdateApplicationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.app != nil && !minimock.Equal(*mm_want_ptrs.app, mm_got.app) {
				mmUpdateApplication.t.Errorf("PostgresRepoMock.UpdateApplication got unexpected parameter app, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateApplication.UpdateApplicationMock.defaultExpectation.expectationOrigins.originApp, *mm_want_ptrs.app, mm_got.app, minimock.Diff(*mm_want_ptrs.app, mm_got.app))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateApplication.t.Errorf("PostgresRepoMock.UpdateApplication got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateApplication.UpdateApplicationMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateApplication.t.Errorf("PostgresRepoMock.UpdateApplication got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateApplication.UpdateApplicationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateApplication.UpdateApplicationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateApplication.t.Fatal("No results are set for the PostgresRepoMock.UpdateApplication")
		}
		return (*mm_results).err
	}
	if mmUpdateApplication.funcUpdateApplication != nil {
		return mmUpdateApplication.funcUpdateApplication(ctx, app, id)
	}
	mmUpdateApplication.t.Fatalf("Unexpected call to PostgresRepoMock.UpdateApplication. %v %v %v", ctx, app, id)
	return
}

// UpdateApplicationAfterCounter returns a count of finished PostgresRepoMock.UpdateApplication invocations
func (mmUpdateApplication *PostgresRepoMock) UpdateApplicationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateApplication.afterUpdateApplicationCounter)
}

// UpdateApplicationBeforeCounter returns a count of PostgresRepoMock.UpdateApplication invocations
func (mmUpdateApplication *PostgresRepoMock) UpdateApplicationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateApplication.beforeUpdateApplicationCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.UpdateApplication.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateApplication *mPostgresRepoMockUpdateApplication) Calls() []*PostgresRepoMockUpdateApplicationParams {
	mmUpdateApplication.mutex.RLock()

	argCopy := make([]*PostgresRepoMockUpdateApplicationParams, len(mmUpdateApplication.callArgs))
	copy(argCopy, mmUpdateApplication.callArgs)

	mmUpdateApplication.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateApplicationDone returns true if the count of the UpdateApplication invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockUpdateApplicationDone() bool {
	if m.UpdateApplicationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateApplicationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateApplicationMock.invocationsDone()
}

// MinimockUpdateApplicationInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockUpdateApplicationInspect() {
	for _, e := range m.UpdateApplicationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.UpdateApplication at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateApplicationCounter := mm_atomic.LoadUint64(&m.afterUpdateApplicationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateApplicationMock.defaultExpectation != nil && afterUpdateApplicationCounter < 1 {
		if m.UpdateApplicationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.UpdateApplication at\n%s", m.UpdateApplicationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.UpdateApplication at\n%s with params: %#v", m.UpdateApplicationMock.defaultExpectation.expectationOrigins.origin, *m.UpdateApplicationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateApplication != nil && afterUpdateApplicationCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.UpdateApplication at\n%s", m.funcUpdateApplicationOrigin)
	}

	if !m.UpdateApplicationMock.invocationsDone() && afterUpdateApplicationCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.UpdateApplication at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateApplicationMock.expectedInvocations), m.UpdateApplicationMock.expectedInvocationsOrigin, afterUpdateApplicationCounter)
	}
}

type mPostgresRepoMockUpdateLatestProfileVersion struct {
	optional           bool
	mock               *PostgresRepoMock
	defaultExpectation *PostgresRepoMockUpdateLatestProfileVersionExpectation
	expectations       []*PostgresRepoMockUpdateLatestProfileVersionExpectation

	callArgs []*PostgresRepoMockUpdateLatestProfileVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostgresRepoMockUpdateLatestProfileVersionExpectation specifies expectation struct of the PostgresRepo.UpdateLatestProfileVersion
type PostgresRepoMockUpdateLatestProfileVersionExpectation struct {
	mock               *PostgresRepoMock
	params             *PostgresRepoMockUpdateLatestProfileVersionParams
	paramPtrs          *PostgresRepoMockUpdateLatestProfileVersionParamPtrs
	expectationOrigins PostgresRepoMockUpdateLatestProfileVersionExpectationOrigins
	results            *PostgresRepoMockUpdateLatestProfileVersionResults
	returnOrigin       string
	Counter            uint64
}

// PostgresRepoMockUpdateLatestProfileVersionParams contains parameters of the PostgresRepo.UpdateLatestProfileVersion
type PostgresRepoMockUpdateLatestProfileVersionParams struct {
	ctx           context.Context
	applicationID uuid.UUID
	version       uint32
}

// PostgresRepoMockUpdateLatestProfileVersionParamPtrs contains pointers to parameters of the PostgresRepo.UpdateLatestProfileVersion
type PostgresRepoMockUpdateLatestProfileVersionParamPtrs struct {
	ctx           *context.Context
	applicationID *uuid.UUID
	version       *uint32
}

// PostgresRepoMockUpdateLatestProfileVersionResults contains results of the PostgresRepo.UpdateLatestProfileVersion
type PostgresRepoMockUpdateLatestProfileVersionResults struct {
	err error
}

// PostgresRepoMockUpdateLatestProfileVersionOrigins contains origins of expectations of the PostgresRepo.UpdateLatestProfileVersion
type PostgresRepoMockUpdateLatestProfileVersionExpectationOrigins struct {
	origin              string
	originCtx           string
	originApplicationID string
	originVersion       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) Optional() *mPostgresRepoMockUpdateLatestProfileVersion {
	mmUpdateLatestProfileVersion.optional = true
	return mmUpdateLatestProfileVersion
}

// Expect sets up expected params for PostgresRepo.UpdateLatestProfileVersion
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) Expect(ctx context.Context, applicationID uuid.UUID, version uint32) *mPostgresRepoMockUpdateLatestProfileVersion {
	if mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersion != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Set")
	}

	if mmUpdateLatestProfileVersion.defaultExpectation == nil {
		mmUpdateLatestProfileVersion.defaultExpectation = &PostgresRepoMockUpdateLatestProfileVersionExpectation{}
	}

	if mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by ExpectParams functions")
	}

	mmUpdateLatestProfileVersion.defaultExpectation.params = &PostgresRepoMockUpdateLatestProfileVersionParams{ctx, applicationID, version}
	mmUpdateLatestProfileVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateLatestProfileVersion.expectations {
		if minimock.Equal(e.params, mmUpdateLatestProfileVersion.defaultExpectation.params) {
			mmUpdateLatestProfileVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateLatestProfileVersion.defaultExpectation.params)
		}
	}

	return mmUpdateLatestProfileVersion
}

// ExpectCtxParam1 sets up expected param ctx for PostgresRepo.UpdateLatestProfileVersion
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) ExpectCtxParam1(ctx context.Context) *mPostgresRepoMockUpdateLatestProfileVersion {
	if mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersion != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Set")
	}

	if mmUpdateLatestProfileVersion.defaultExpectation == nil {
		mmUpdateLatestProfileVersion.defaultExpectation = &PostgresRepoMockUpdateLatestProfileVersionExpectation{}
	}

	if mmUpdateLatestProfileVersion.defaultExpectation.params != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Expect")
	}

	if mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs == nil {
		mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs = &PostgresRepoMockUpdateLatestProfileVersionParamPtrs{}
	}
	mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateLatestProfileVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateLatestProfileVersion
}

// ExpectApplicationIDParam2 sets up expected param applicationID for PostgresRepo.UpdateLatestProfileVersion
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) ExpectApplicationIDParam2(applicationID uuid.UUID) *mPostgresRepoMockUpdateLatestProfileVersion {
	if mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersion != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Set")
	}

	if mmUpdateLatestProfileVersion.defaultExpectation == nil {
		mmUpdateLatestProfileVersion.defaultExpectation = &PostgresRepoMockUpdateLatestProfileVersionExpectation{}
	}

	if mmUpdateLatestProfileVersion.defaultExpectation.params != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Expect")
	}

	if mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs == nil {
		mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs = &PostgresRepoMockUpdateLatestProfileVersionParamPtrs{}
	}
	mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs.applicationID = &applicationID
	mmUpdateLatestProfileVersion.defaultExpectation.expectationOrigins.originApplicationID = minimock.CallerInfo(1)

	return mmUpdateLatestProfileVersion
}

// ExpectVersionParam3 sets up expected param version for PostgresRepo.UpdateLatestProfileVersion
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) ExpectVersionParam3(version uint32) *mPostgresRepoMockUpdateLatestProfileVersion {
	if mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersion != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Set")
	}

	if mmUpdateLatestProfileVersion.defaultExpectation == nil {
		mmUpdateLatestProfileVersion.defaultExpectation = &PostgresRepoMockUpdateLatestProfileVersionExpectation{}
	}

	if mmUpdateLatestProfileVersion.defaultExpectation.params != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Expect")
	}

	if mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs == nil {
		mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs = &PostgresRepoMockUpdateLatestProfileVersionParamPtrs{}
	}
	mmUpdateLatestProfileVersion.defaultExpectation.paramPtrs.version = &version
	mmUpdateLatestProfileVersion.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmUpdateLatestProfileVersion
}

// Inspect accepts an inspector function that has same arguments as the PostgresRepo.UpdateLatestProfileVersion
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) Inspect(f func(ctx context.Context, applicationID uuid.UUID, version uint32)) *mPostgresRepoMockUpdateLatestProfileVersion {
	if mmUpdateLatestProfileVersion.mock.inspectFuncUpdateLatestProfileVersion != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("Inspect function is already set for PostgresRepoMock.UpdateLatestProfileVersion")
	}

	mmUpdateLatestProfileVersion.mock.inspectFuncUpdateLatestProfileVersion = f

	return mmUpdateLatestProfileVersion
}

// Return sets up results that will be returned by PostgresRepo.UpdateLatestProfileVersion
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) Return(err error) *PostgresRepoMock {
	if mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersion != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Set")
	}

	if mmUpdateLatestProfileVersion.defaultExpectation == nil {
		mmUpdateLatestProfileVersion.defaultExpectation = &PostgresRepoMockUpdateLatestProfileVersionExpectation{mock: mmUpdateLatestProfileVersion.mock}
	}
	mmUpdateLatestProfileVersion.defaultExpectation.results = &PostgresRepoMockUpdateLatestProfileVersionResults{err}
	mmUpdateLatestProfileVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateLatestProfileVersion.mock
}

// Set uses given function f to mock the PostgresRepo.UpdateLatestProfileVersion method
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) Set(f func(ctx context.Context, applicationID uuid.UUID, version uint32) (err error)) *PostgresRepoMock {
	if mmUpdateLatestProfileVersion.defaultExpectation != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("Default expectation is already set for the PostgresRepo.UpdateLatestProfileVersion method")
	}

	if len(mmUpdateLatestProfileVersion.expectations) > 0 {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("Some expectations are already set for the PostgresRepo.UpdateLatestProfileVersion method")
	}

	mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersion = f
	mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersionOrigin = minimock.CallerInfo(1)
	return mmUpdateLatestProfileVersion.mock
}

// When sets expectation for the PostgresRepo.UpdateLatestProfileVersion which will trigger the result defined by the following
// Then helper
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) When(ctx context.Context, applicationID uuid.UUID, version uint32) *PostgresRepoMockUpdateLatestProfileVersionExpectation {
	if mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersion != nil {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("PostgresRepoMock.UpdateLatestProfileVersion mock is already set by Set")
	}

	expectation := &PostgresRepoMockUpdateLatestProfileVersionExpectation{
		mock:               mmUpdateLatestProfileVersion.mock,
		params:             &PostgresRepoMockUpdateLatestProfileVersionParams{ctx, applicationID, version},
		expectationOrigins: PostgresRepoMockUpdateLatestProfileVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateLatestProfileVersion.expectations = append(mmUpdateLatestProfileVersion.expectations, expectation)
	return expectation
}

// Then sets up PostgresRepo.UpdateLatestProfileVersion return parameters for the expectation previously defined by the When method
func (e *PostgresRepoMockUpdateLatestProfileVersionExpectation) Then(err error) *PostgresRepoMock {
	e.results = &PostgresRepoMockUpdateLatestProfileVersionResults{err}
	return e.mock
}

// Times sets number of times PostgresRepo.UpdateLatestProfileVersion should be invoked
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) Times(n uint64) *mPostgresRepoMockUpdateLatestProfileVersion {
	if n == 0 {
		mmUpdateLatestProfileVersion.mock.t.Fatalf("Times of PostgresRepoMock.UpdateLatestProfileVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateLatestProfileVersion.expectedInvocations, n)
	mmUpdateLatestProfileVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateLatestProfileVersion
}

func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) invocationsDone() bool {
	if len(mmUpdateLatestProfileVersion.expectations) == 0 && mmUpdateLatestProfileVersion.defaultExpectation == nil && mmUpdateLatestProfileVersion.mock.funcUpdateLatestProfileVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateLatestProfileVersion.mock.afterUpdateLatestProfileVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateLatestProfileVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateLatestProfileVersion implements mm_usecase.PostgresRepo
func (mmUpdateLatestProfileVersion *PostgresRepoMock) UpdateLatestProfileVersion(ctx context.Context, applicationID uuid.UUID, version uint32) (err error) {
	mm_atomic.AddUint64(&mmUpdateLatestProfileVersion.beforeUpdateLatestProfileVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateLatestProfileVersion.afterUpdateLatestProfileVersionCounter, 1)

	mmUpdateLatestProfileVersion.t.Helper()

	if mmUpdateLatestProfileVersion.inspectFuncUpdateLatestProfileVersion != nil {
		mmUpdateLatestProfileVersion.inspectFuncUpdateLatestProfileVersion(ctx, applicationID, version)
	}

	mm_params := PostgresRepoMockUpdateLatestProfileVersionParams{ctx, applicationID, version}

	// Record call args
	mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.mutex.Lock()
	mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.callArgs = append(mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.callArgs, &mm_params)
	mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.mutex.Unlock()

	for _, e := range mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation.paramPtrs

		mm_got := PostgresRepoMockUpdateLatestProfileVersionParams{ctx, applicationID, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateLatestProfileVersion.t.Errorf("PostgresRepoMock.UpdateLatestProfileVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.applicationID != nil && !minimock.Equal(*mm_want_ptrs.applicationID, mm_got.applicationID) {
				mmUpdateLatestProfileVersion.t.Errorf("PostgresRepoMock.UpdateLatestProfileVersion got unexpected parameter applicationID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation.expectationOrigins.originApplicationID, *mm_want_ptrs.applicationID, mm_got.applicationID, minimock.Diff(*mm_want_ptrs.applicationID, mm_got.applicationID))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmUpdateLatestProfileVersion.t.Errorf("PostgresRepoMock.UpdateLatestProfileVersion got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateLatestProfileVersion.t.Errorf("PostgresRepoMock.UpdateLatestProfileVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateLatestProfileVersion.UpdateLatestProfileVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateLatestProfileVersion.t.Fatal("No results are set for the PostgresRepoMock.UpdateLatestProfileVersion")
		}
		return (*mm_results).err
	}
	if mmUpdateLatestProfileVersion.funcUpdateLatestProfileVersion != nil {
		return mmUpdateLatestProfileVersion.funcUpdateLatestProfileVersion(ctx, applicationID, version)
	}
	mmUpdateLatestProfileVersion.t.Fatalf("Unexpected call to PostgresRepoMock.UpdateLatestProfileVersion. %v %v %v", ctx, applicationID, version)
	return
}

// UpdateLatestProfileVersionAfterCounter returns a count of finished PostgresRepoMock.UpdateLatestProfileVersion invocations
func (mmUpdateLatestProfileVersion *PostgresRepoMock) UpdateLatestProfileVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateLatestProfileVersion.afterUpdateLatestProfileVersionCounter)
}

// UpdateLatestProfileVersionBeforeCounter returns a count of PostgresRepoMock.UpdateLatestProfileVersion invocations
func (mmUpdateLatestProfileVersion *PostgresRepoMock) UpdateLatestProfileVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateLatestProfileVersion.beforeUpdateLatestProfileVersionCounter)
}

// Calls returns a list of arguments used in each call to PostgresRepoMock.UpdateLatestProfileVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateLatestProfileVersion *mPostgresRepoMockUpdateLatestProfileVersion) Calls() []*PostgresRepoMockUpdateLatestProfileVersionParams {
	mmUpdateLatestProfileVersion.mutex.RLock()

	argCopy := make([]*PostgresRepoMockUpdateLatestProfileVersionParams, len(mmUpdateLatestProfileVersion.callArgs))
	copy(argCopy, mmUpdateLatestProfileVersion.callArgs)

	mmUpdateLatestProfileVersion.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateLatestProfileVersionDone returns true if the count of the UpdateLatestProfileVersion invocations corresponds
// the number of defined expectations
func (m *PostgresRepoMock) MinimockUpdateLatestProfileVersionDone() bool {
	if m.UpdateLatestProfileVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateLatestProfileVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateLatestProfileVersionMock.invocationsDone()
}

// MinimockUpdateLatestProfileVersionInspect logs each unmet expectation
func (m *PostgresRepoMock) MinimockUpdateLatestProfileVersionInspect() {
	for _, e := range m.UpdateLatestProfileVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresRepoMock.UpdateLatestProfileVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateLatestProfileVersionCounter := mm_atomic.LoadUint64(&m.afterUpdateLatestProfileVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateLatestProfileVersionMock.defaultExpectation != nil && afterUpdateLatestProfileVersionCounter < 1 {
		if m.UpdateLatestProfileVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostgresRepoMock.UpdateLatestProfileVersion at\n%s", m.UpdateLatestProfileVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostgresRepoMock.UpdateLatestProfileVersion at\n%s with params: %#v", m.UpdateLatestProfileVersionMock.defaultExpectation.expectationOrigins.origin, *m.UpdateLatestProfileVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateLatestProfileVersion != nil && afterUpdateLatestProfileVersionCounter < 1 {
		m.t.Errorf("Expected call to PostgresRepoMock.UpdateLatestProfileVersion at\n%s", m.funcUpdateLatestProfileVersionOrigin)
	}

	if !m.UpdateLatestProfileVersionMock.invocationsDone() && afterUpdateLatestProfileVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to PostgresRepoMock.UpdateLatestProfileVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateLatestProfileVersionMock.expectedInvocations), m.UpdateLatestProfileVersionMock.expectedInvocationsOrigin, afterUpdateLatestProfileVersionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PostgresRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateApplicationInspect()

			m.MinimockCreateApplicationProfileInspect()

			m.MinimockDeleteApplicationInspect()

			m.MinimockDeleteApplicationProfileInspect()

			m.MinimockGetApplicationInspect()

			m.MinimockGetApplicationProfileByIDInspect()

			m.MinimockGetApplicationProfileByVersionInspect()

			m.MinimockGetLatestApplicationProfileInspect()

			m.MinimockGetLatestVersionForUpdateInspect()

			m.MinimockListApplicationProfilesInspect()

			m.MinimockListApplicationsInspect()

			m.MinimockListLatestApplicationProfilesInspect()

			m.MinimockUpdateApplicationInspect()

			m.MinimockUpdateLatestProfileVersionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PostgresRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PostgresRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateApplicationDone() &&
		m.MinimockCreateApplicationProfileDone() &&
		m.MinimockDeleteApplicationDone() &&
		m.MinimockDeleteApplicationProfileDone() &&
		m.MinimockGetApplicationDone() &&
		m.MinimockGetApplicationProfileByIDDone() &&
		m.MinimockGetApplicationProfileByVersionDone() &&
		m.MinimockGetLatestApplicationProfileDone() &&
		m.MinimockGetLatestVersionForUpdateDone() &&
		m.MinimockListApplicationProfilesDone() &&
		m.MinimockListApplicationsDone() &&
		m.MinimockListLatestApplicationProfilesDone() &&
		m.MinimockUpdateApplicationDone() &&
		m.MinimockUpdateLatestProfileVersionDone()
}
